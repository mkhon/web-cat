package net.sf.webcat.reporter;
// Generated by the WOLips Templateengine Plug-in at Jan 30, 2007 1:13:07 PM

import java.io.File;

import net.sf.webcat.grader.FinalReportPage;

import org.apache.log4j.Logger;

import com.webobjects.appserver.*;
import com.webobjects.eocontrol.EOAndQualifier;
import com.webobjects.eocontrol.EOFetchSpecification;
import com.webobjects.eocontrol.EOKeyValueQualifier;
import com.webobjects.eocontrol.EOQualifier;
import com.webobjects.eocontrol.EOSortOrdering;
import com.webobjects.foundation.NSArray;
import com.webobjects.foundation.NSMutableArray;
import com.webobjects.foundation.NSTimestamp;

import er.extensions.ERXConstant;

public class GeneratedReportPage extends ReporterComponent
{
//	public GeneratedReport generatedReport;

    /** The associated refresh interval for this page */
    public int refreshTimeout = 15;

    public GeneratedReportPage(WOContext context)
    {
        super(context);
    }

    public void appendToResponse(WOResponse response, WOContext context)
    {
//    	checkIfReportGenerated();
    	
    	super.appendToResponse(response, context);
    }
    
    public GeneratedReport generatedReport()
    {
    	NSArray reports = GeneratedReport.objectsForUuid(
    			wcSession().localContext(), reportUuidInSession());
    	
    	if(reports.count() > 0)
    	{
    		if(reports.count() != 1)
    		{
    			log.warn("There is more than one report with uuid " +
    					reportUuidInSession() + "!");
    		}
    		
    		GeneratedReport report = (GeneratedReport)reports.objectAtIndex(0);
    		
    		if(report.isRendered())
    		{
    			return report;
    		}
    	}

    	return null;
    }
    
    
    // ----------------------------------------------------------
    /**
     * Returns null to force a reload of the current page.
     * @return always null, to refresh the current page
     */
    public WOComponent refreshAction()
    {
        return null;
    }
    
    
    public Object jobToken()
    {
    	return reportUuidInSession();
    }

    public AjaxLongResponseHandler longResponseHandler()
    {
    	return new AjaxLongResponseHandler() {
    		public void cancel()
    		{
    			Reporter.getInstance().reportQueueProcessor().cancelJobWithUuid(
    					wcSession().localContext(), reportUuidInSession());
    		}
    	};
    }
    
    public void setLongResponseHandler(AjaxLongResponseHandler handler)
    {    	
    }

    // ----------------------------------------------------------
    public int queuedJobCount()
    {
        ensureJobDataIsInitialized();
        return jobData.queueSize;
    }


    // ----------------------------------------------------------
    public int queuePosition()
    {
        ensureJobDataIsInitialized();
        return jobData.queuePosition + 1;
    }


    // ----------------------------------------------------------
    /**
     * Returns the estimated time needed to complete processing this job.
     * @return the most recent job wait
     */
    public NSTimestamp estimatedWait()
    {
        ensureJobDataIsInitialized();
        return new NSTimestamp( jobData.estimatedWait );
    }


    // ----------------------------------------------------------
    /**
     * Returns the time taken to process the most recent job.
     * @return the most recent job wait
     */
    public NSTimestamp mostRecentJobWait()
    {
        ensureJobDataIsInitialized();
        return new NSTimestamp( jobData.mostRecentWait );
    }


    // ----------------------------------------------------------
    /**
     * Returns the date format string for the corresponding time value
     * @param timeDelta the time to format
     * @return the time format to use
     */
    public static String formatForSmallTime( long timeDelta )
    {
        String format = "%j days, %H:%M:%S";
        final int minute = 60 * 1000;
        final int hour   = 60 * minute;
        final int day    = 24 * hour;
        if ( timeDelta < minute )
        {
            format = "%S seconds";
        }
        else if ( timeDelta < hour )
        {
            format = "%M:%S minutes";
        }
        else if ( timeDelta < day )
        {
            format = "%H:%M:%S hours";
        }
        return format;
    }


    // ----------------------------------------------------------
    /**
     * Returns the date format string for the corresponding time value
     * @return the time format for the estimated job wait
     */
    public String estimatedWaitFormat()
    {
        ensureJobDataIsInitialized();
        return formatForSmallTime( jobData.estimatedWait );
    }


    // ----------------------------------------------------------
    /**
     * Returns the date format string for the corresponding time value
     * @return the time format for the most recent job wait
     */
    public String mostRecentJobWaitFormat()
    {
        ensureJobDataIsInitialized();
        return formatForSmallTime( jobData.mostRecentWait );
    }

    
    // ----------------------------------------------------------
    static private class JobData
    {
        public NSArray jobs;
        public int queueSize;
        public int queuePosition;
        long mostRecentWait;
        long estimatedWait;
    }


    // ----------------------------------------------------------
    private void ensureJobDataIsInitialized()
    {
        if ( jobData == null )
        {
            jobData = new JobData();
            NSMutableArray qualifiers = new NSMutableArray();
            qualifiers.addObject( new EOKeyValueQualifier(
                            EnqueuedReportJob.DISCARDED_KEY,
                            EOQualifier.QualifierOperatorEqual,
                            ERXConstant.integerForInt( 0 )
            ) );
            qualifiers.addObject( new EOKeyValueQualifier(
                            EnqueuedReportJob.PAUSED_KEY,
                            EOQualifier.QualifierOperatorEqual,
                            ERXConstant.integerForInt( 0 )
            ) );
            EOFetchSpecification fetchSpec =
                new EOFetchSpecification(
                        EnqueuedReportJob.ENTITY_NAME,
                        new EOAndQualifier( qualifiers ),
                        new NSArray( new Object[]{
                                new EOSortOrdering(
                                        EnqueuedReportJob.QUEUE_TIME_KEY,
                                        EOSortOrdering.CompareAscending
                                    )
                            } )
                    );
            jobData.jobs =
                wcSession().localContext().objectsWithFetchSpecification(
                    fetchSpec
                );
            jobData.queueSize = jobData.jobs.count();
            if ( oldQueuePos < 0
                 || oldQueuePos >= jobData.queueSize )
            {
                oldQueuePos = jobData.queueSize - 1;
            }
            jobData.queuePosition = jobData.queueSize;
            for ( int i = oldQueuePos; i >= 0; i-- )
            {
                if ( jobData.jobs.objectAtIndex( i )
                     == enqueuedJobInSession() )
                {
                    jobData.queuePosition = i;
                    break;
                }
            }
            oldQueuePos = jobData.queuePosition;
            if ( jobData.queuePosition == jobData.queueSize )
            {
                log.error( "cannot find job in queue for:"
                           + enqueuedJobInSession() );
            }

            //Reporter reporter = Reporter.getInstance();
            jobData.mostRecentWait = 0; //reporter.mostRecentJobWait();
            jobData.estimatedWait = 0; //
                //reporter.estimatedJobTime() * ( jobData.queuePosition + 1 );
        }
    }


    //~ Instance/static variables .............................................

    private JobData jobData;
    private int     oldQueuePos = -1;
    
    static Logger log = Logger.getLogger( GeneratedReportPage.class );
}