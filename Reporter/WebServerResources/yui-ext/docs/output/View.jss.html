<html><head><title>View.js</title><link rel="stylesheet" type="text/css" href="../resources/style.css" media="screen"/></head><body><h1>View.js</h1><pre class="highlighted"><code><i>/**
 * @class Ext.View
 * @extends Ext.util.Observable
 * Create a &quot;View&quot; <b>for</b> an element based on a data model or UpdateManager and the supplied DomHelper template. 
 * This class also supports single and multi selection modes. &lt;br&gt;
 * Create a data model bound view:
 &lt;pre&gt;&lt;code&gt;
 <b>var</b> store = <b>new</b> Ext.data.Store(...);

 <b>var</b> view = <b>new</b> Ext.View(&quot;my-element&quot;,
 '&amp;lt;div id=&quot;{0}&quot;&amp;gt;{2} - {1}&amp;lt;/div&amp;gt;', <i>// auto create template</i>
 {
 singleSelect: true,
 selectedClass: &quot;ydataview-selected&quot;,
 store: store
 });

 <i>// listen <b>for</b> node click?</i>
 view.on(&quot;click&quot;, <b>function</b>(vw, index, node, e){
 alert('Node &quot;' + node.id + '&quot; at index: ' + index + &quot; was clicked.&quot;);
 });

 <i>// load XML data</i>
 dataModel.load(&quot;foobar.xml&quot;);
 &lt;/code&gt;&lt;/pre&gt;
 For an example of creating a JSON/UpdateManager view, see {@link Ext.JsonView}.
 * &lt;br&gt;&lt;br&gt;
 * &lt;b&gt;Note: The root of your template must be a single node. Table/row implementations may work but are not supported due to
 * IE&quot;s limited insertion support <b>with</b> tables and Opera&quot;s faulty event bubbling.&lt;/b&gt;
 * @constructor
 * Create a <b>new</b> View
 * @param {String/HTMLElement/Element} container The container element where the view is to be rendered.
 * @param {String/DomHelper.Template} tpl The rendering template or a string to create a template <b>with</b>
 * @param {Object} config The config object
 */</i>
Ext.View = <b>function</b>(container, tpl, config){
    <b>this</b>.el = Ext.get(container, true);
    <b>if</b>(typeof tpl == &quot;string&quot;){
        tpl = <b>new</b> Ext.Template(tpl);
    }
    tpl.compile();
    <i>/**
     * The template used by <b>this</b> View
     * @type {Ext.DomHelper.Template}
     */</i>
    <b>this</b>.tpl = tpl;

    Ext.apply(<b>this</b>, config);

    <i>/** @private */</i>
    <b>this</b>.events = {
    <i>/**
     * @event beforeclick
     * Fires before a click is processed. Returns false to cancel the <b>default</b> action.
     * @param {Ext.View} <b>this</b>
     * @param {Number} index The index of the target node
     * @param {HTMLElement} node The target node
     * @param {Ext.EventObject} e The raw event object
     */</i>
        &quot;beforeclick&quot; : true,
    <i>/**
     * @event click
     * Fires when a template node is clicked.
     * @param {Ext.View} <b>this</b>
     * @param {Number} index The index of the target node
     * @param {HTMLElement} node The target node
     * @param {Ext.EventObject} e The raw event object
     */</i>
        &quot;click&quot; : true,
    <i>/**
     * @event dblclick
     * Fires when a template node is double clicked.
     * @param {Ext.View} <b>this</b>
     * @param {Number} index The index of the target node
     * @param {HTMLElement} node The target node
     * @param {Ext.EventObject} e The raw event object
     */</i>
        &quot;dblclick&quot; : true,
    <i>/**
     * @event contextmenu
     * Fires when a template node is right clicked.
     * @param {Ext.View} <b>this</b>
     * @param {Number} index The index of the target node
     * @param {HTMLElement} node The target node
     * @param {Ext.EventObject} e The raw event object
     */</i>
        &quot;contextmenu&quot; : true,
    <i>/**
     * @event selectionchange
     * Fires when the selected nodes change.
     * @param {Ext.View} <b>this</b>
     * @param {Array} selections Array of the selected nodes
     */</i>
        &quot;selectionchange&quot; : true,

    <i>/**
     * @event beforeselect
     * Fires before a selection is made. If any handlers <b>return</b> false, the selection is cancelled.
     * @param {Ext.View} <b>this</b>
     * @param {HTMLElement} node The node to be selected
     * @param {Array} selections Array of currently selected nodes
     */</i>
        &quot;beforeselect&quot; : true
    };

    <b>this</b>.el.on({
        &quot;click&quot;: <b>this</b>.onClick,
        &quot;dblclick&quot;: <b>this</b>.onDblClick,
        &quot;contextmenu&quot;: <b>this</b>.onContextMenu,
        scope:<b>this</b>
    });

    <b>this</b>.selections = [];
    <b>this</b>.nodes = [];
    <b>this</b>.cmp = <b>new</b> Ext.CompositeElementLite([]);
    <b>if</b>(this.store){
        <b>this</b>.setStore(<b>this</b>.store, true);
    }
};

Ext.extend(Ext.View, Ext.util.Observable, {
    <i>/**
     * The css class to add to selected nodes
     * @type {Ext.DomHelper.Template}
     */</i>
    selectedClass : &quot;x-view-selected&quot;,
    
    emptyText : &quot;&quot;,
    <i>/**
     * Returns the element <b>this</b> view is bound to.
     * @<b>return</b> {Ext.Element}
     */</i>
    getEl : <b>function</b>(){
        <b>return</b> this.el;
    },

    <i>/**
     * Refreshes the view.
     */</i>
    refresh : <b>function</b>(){
        <b>var</b> t = <b>this</b>.tpl;
        <b>this</b>.clearSelections();
        <b>this</b>.el.update(&quot;&quot;);
        <b>var</b> html = [];
        <b>var</b> records = <b>this</b>.store.getRange();
        <b>if</b>(records.length &lt; 1){
            <b>this</b>.el.update(<b>this</b>.emptyText);
            <b>return</b>;
        }
        <b>for</b>(var i = 0, len = records.length; i &lt; len; i++){
            <b>var</b> data = <b>this</b>.prepareData(records[i].data, i, records[i]);
            html[html.length] = t.apply(data);
        }
        <b>this</b>.el.update(html.join(&quot;&quot;));
        <b>this</b>.nodes = <b>this</b>.el.dom.childNodes;
        <b>this</b>.updateIndexes(0);
    },

    <i>/**
     * Function to override to reformat the data that is sent to
     * the template <b>for</b> each node.
     * @param {Array/Object} data The raw data (array of colData <b>for</b> a data model bound view or
     * a JSON object <b>for</b> an UpdateManager bound view).
     * @param {Number} index The index of the data within the data model
     */</i>
    prepareData : <b>function</b>(data, index){
        <b>return</b> data;
    },

    onUpdate : <b>function</b>(ds, record){
        <b>this</b>.clearSelections();
        <b>var</b> index = <b>this</b>.store.indexOf(record);
        <b>var</b> n = <b>this</b>.nodes[index];
        <b>this</b>.tpl.insertBefore(n, <b>this</b>.prepareData(record.data));
        n.parentNode.removeChild(n);
        <b>this</b>.updateIndexes(index, index);
    },

    onAdd : <b>function</b>(ds, records, index){
        <b>this</b>.clearSelections();
        <b>if</b>(this.nodes.length == 0){
            <b>this</b>.refresh();
            <b>return</b>;
        }
        <b>var</b> n = <b>this</b>.nodes[index];
        <b>for</b>(var i = 0, len = records.length; i &lt; len; i++){
            <b>var</b> d = <b>this</b>.prepareData(records[i].data);
            <b>if</b>(n){
                <b>this</b>.tpl.insertBefore(n, d);
            }<b>else</b>{
                <b>this</b>.tpl.append(<b>this</b>.el, d);
            }
        }
        <b>this</b>.updateIndexes(index);
    },

    onRemove : <b>function</b>(ds, record, index){
        <b>this</b>.clearSelections();
        <b>this</b>.el.dom.removeChild(<b>this</b>.nodes[index]);
        <b>this</b>.updateIndexes(index);
    },

    <i>/**
     * Refresh an individual node.
     * @param {Number} index
     */</i>
    refreshNode : <b>function</b>(index){
        <b>this</b>.onUpdate(<b>this</b>.store, <b>this</b>.store.getAt(index));
    },

    updateIndexes : <b>function</b>(startIndex, endIndex){
        <b>var</b> ns = <b>this</b>.nodes;
        startIndex = startIndex || 0;
        endIndex = endIndex || ns.length - 1;
        <b>for</b>(var i = startIndex; i &lt;= endIndex; i++){
            ns[i].nodeIndex = i;
        }
    },

    <i>/**
     * Changes the data store <b>this</b> view uses and refresh the view.
     * @param {Store} store
     */</i>
    setStore : <b>function</b>(store, initial){
        <b>if</b>(!initial &amp;&amp; <b>this</b>.store){
            <b>this</b>.store.un(&quot;datachanged&quot;, <b>this</b>.refresh);
            <b>this</b>.store.un(&quot;add&quot;, <b>this</b>.onAdd);
            <b>this</b>.store.un(&quot;remove&quot;, <b>this</b>.onRemove);
            <b>this</b>.store.un(&quot;update&quot;, <b>this</b>.onUpdate);
            <b>this</b>.store.un(&quot;clear&quot;, <b>this</b>.refresh);
        }
        <b>if</b>(store){
            store.on(&quot;datachanged&quot;, <b>this</b>.refresh, <b>this</b>);
            store.on(&quot;add&quot;, <b>this</b>.onAdd, <b>this</b>);
            store.on(&quot;remove&quot;, <b>this</b>.onRemove, <b>this</b>);
            store.on(&quot;update&quot;, <b>this</b>.onUpdate, <b>this</b>);
            store.on(&quot;clear&quot;, <b>this</b>.refresh, <b>this</b>);
        }
        <b>this</b>.store = store;
        <b>this</b>.refresh();
    },

    <i>/**
     * Returns the template node the passed child belongs to or null <b>if</b> it doesn't belong to one.
     * @param {HTMLElement} node
     * @<b>return</b> {HTMLElement} The template node
     */</i>
    findItemFromChild : <b>function</b>(node){
        <b>var</b> el = <b>this</b>.el.dom;
        <b>if</b>(!node || node.parentNode == el){
		    <b>return</b> node;
	    }
	    <b>var</b> p = node.parentNode;
	    <b>while</b>(p &amp;&amp; p != el){
            <b>if</b>(p.parentNode == el){
            	<b>return</b> p;
            }
            p = p.parentNode;
        }
	    <b>return</b> null;
    },

    <i>/** @ignore */</i>
    onClick : <b>function</b>(e){
        <b>var</b> item = <b>this</b>.findItemFromChild(e.getTarget());
        <b>if</b>(item){
            <b>var</b> index = <b>this</b>.indexOf(item);
            <b>if</b>(this.onItemClick(item, index, e) !== false){
                <b>this</b>.fireEvent(&quot;click&quot;, <b>this</b>, index, item, e);
            }
        }<b>else</b>{
            <b>this</b>.clearSelections();
        }
    },

    <i>/** @ignore */</i>
    onContextMenu : <b>function</b>(e){
        <b>var</b> item = <b>this</b>.findItemFromChild(e.getTarget());
        <b>if</b>(item){
            <b>this</b>.fireEvent(&quot;contextmenu&quot;, <b>this</b>, <b>this</b>.indexOf(item), item, e);
        }
    },

    <i>/** @ignore */</i>
    onDblClick : <b>function</b>(e){
        <b>var</b> item = <b>this</b>.findItemFromChild(e.getTarget());
        <b>if</b>(item){
            <b>this</b>.fireEvent(&quot;dblclick&quot;, <b>this</b>, <b>this</b>.indexOf(item), item, e);
        }
    },

    onItemClick : <b>function</b>(item, index, e){
        <b>if</b>(this.fireEvent(&quot;beforeclick&quot;, <b>this</b>, index, item, e) === false){
            <b>return</b> false;
        }
        <b>if</b>(this.multiSelect || <b>this</b>.singleSelect){
            <b>if</b>(this.multiSelect &amp;&amp; e.shiftKey &amp;&amp; <b>this</b>.lastSelection){
                <b>this</b>.select(<b>this</b>.getNodes(<b>this</b>.indexOf(<b>this</b>.lastSelection), index), false);
            }<b>else</b>{
                <b>this</b>.select(item, <b>this</b>.multiSelect &amp;&amp; e.ctrlKey);
                <b>this</b>.lastSelection = item;
            }
            e.preventDefault();
        }
        <b>return</b> true;
    },

    <i>/**
     * Get the number of selected nodes.
     * @<b>return</b> {Number}
     */</i>
    getSelectionCount : <b>function</b>(){
        <b>return</b> this.selections.length;
    },

    <i>/**
     * Get the currently selected nodes.
     * @<b>return</b> {Array} An array of HTMLElements
     */</i>
    getSelectedNodes : <b>function</b>(){
        <b>return</b> this.selections;
    },

    <i>/**
     * Get the indexes of the selected nodes.
     * @<b>return</b> {Array}
     */</i>
    getSelectedIndexes : <b>function</b>(){
        <b>var</b> indexes = [], s = <b>this</b>.selections;
        <b>for</b>(var i = 0, len = s.length; i &lt; len; i++){
            indexes.push(s[i].nodeIndex);
        }
        <b>return</b> indexes;
    },

    <i>/**
     * Clear all selections
     * @param {Boolean} suppressEvent (optional) true to skip firing of the selectionchange event
     */</i>
    clearSelections : <b>function</b>(suppressEvent){
        <b>if</b>(this.nodes &amp;&amp; (<b>this</b>.multiSelect || <b>this</b>.singleSelect)){
            <b>this</b>.cmp.elements = <b>this</b>.selections;
            <b>this</b>.cmp.removeClass(<b>this</b>.selectedClass);
            <b>this</b>.selections = [];
            <b>if</b>(!suppressEvent){
                <b>this</b>.fireEvent(&quot;selectionchange&quot;, <b>this</b>, <b>this</b>.selections);
            }
        }
    },

    <i>/**
     * Returns true <b>if</b> the passed node is selected
     * @param {HTMLElement/Number} node The node or node index
     * @<b>return</b> {Boolean}
     */</i>
    isSelected : <b>function</b>(node){
        <b>var</b> s = <b>this</b>.selections;
        <b>if</b>(s.length &lt; 1){
            <b>return</b> false;
        }
        node = <b>this</b>.getNode(node);
        <b>return</b> s.indexOf(node) !== -1;
    },

    <i>/**
     * Selects nodes.
     * @param {Array/HTMLElement/String/Number} nodeInfo An HTMLElement template node, index of a template node, id of a template node or an array of any of those to select
     * @param {Boolean} keepExisting (optional) true to keep existing selections
     * @param {Boolean} suppressEvent (optional) true to skip firing of the selectionchange vent
     */</i>
    select : <b>function</b>(nodeInfo, keepExisting, suppressEvent){
        <b>if</b>(nodeInfo instanceof Array){
            <b>if</b>(!keepExisting){
                <b>this</b>.clearSelections(true);
            }
            <b>for</b>(var i = 0, len = nodeInfo.length; i &lt; len; i++){
                <b>this</b>.select(nodeInfo[i], true, true);
            }
        } <b>else</b>{
            <b>var</b> node = <b>this</b>.getNode(nodeInfo);
            <b>if</b>(node &amp;&amp; !<b>this</b>.isSelected(node)){
                <b>if</b>(!keepExisting){
                    <b>this</b>.clearSelections(true);
                }
                <b>if</b>(this.fireEvent(&quot;beforeselect&quot;, <b>this</b>, node, <b>this</b>.selections) !== false){
                    Ext.fly(node).addClass(<b>this</b>.selectedClass);
                    <b>this</b>.selections.push(node);
                    <b>if</b>(!suppressEvent){
                        <b>this</b>.fireEvent(&quot;selectionchange&quot;, <b>this</b>, <b>this</b>.selections);
                    }
                }
            }
        }
    },

    <i>/**
     * Gets a template node.
     * @param {HTMLElement/String/Number} nodeInfo An HTMLElement template node, index of a template node or the id of a template node
     * @<b>return</b> {HTMLElement} The node or null <b>if</b> it wasn't found
     */</i>
    getNode : <b>function</b>(nodeInfo){
        <b>if</b>(typeof nodeInfo == &quot;string&quot;){
            <b>return</b> document.getElementById(nodeInfo);
        }<b>else</b> if(<b>typeof</b> nodeInfo == &quot;number&quot;){
            <b>return</b> this.nodes[nodeInfo];
        }
        <b>return</b> nodeInfo;
    },

    <i>/**
     * Gets a range template nodes.
     * @param {Number} startIndex
     * @param {Number} endIndex
     * @<b>return</b> {Array} An array of nodes
     */</i>
    getNodes : <b>function</b>(start, end){
        <b>var</b> ns = <b>this</b>.nodes;
        start = start || 0;
        end = <b>typeof</b> end == &quot;undefined&quot; ? ns.length - 1 : end;
        <b>var</b> nodes = [];
        <b>if</b>(start &lt;= end){
            <b>for</b>(var i = start; i &lt;= end; i++){
                nodes.push(ns[i]);
            }
        } <b>else</b>{
            <b>for</b>(var i = start; i &gt;= end; i--){
                nodes.push(ns[i]);
            }
        }
        <b>return</b> nodes;
    },

    <i>/**
     * Finds the index of the passed node
     * @param {HTMLElement/String/Number} nodeInfo An HTMLElement template node, index of a template node or the id of a template node
     * @<b>return</b> {Number} The index of the node or -1
     */</i>
    indexOf : <b>function</b>(node){
        node = <b>this</b>.getNode(node);
        <b>if</b>(typeof node.nodeIndex == &quot;number&quot;){
            <b>return</b> node.nodeIndex;
        }
        <b>var</b> ns = <b>this</b>.nodes;
        <b>for</b>(var i = 0, len = ns.length; i &lt; len; i++){
            <b>if</b>(ns[i] == node){
                <b>return</b> i;
            }
        }
        <b>return</b> -1;
    }
});

<i>/**
 * @class Ext.JsonView
 * @extends Ext.View
 * Shortcut class to create a JSON + UpdateManager template view. Usage:
 &lt;pre&gt;&lt;code&gt;
 <b>var</b> view = <b>new</b> Ext.JsonView(&quot;my-element&quot;,
 '&amp;lt;div id=&quot;{id}&quot;&amp;gt;{foo} - {bar}&amp;lt;/div&amp;gt;', <i>// auto create template</i>
 { multiSelect: true, jsonRoot: &quot;data&quot; });

 <i>// listen <b>for</b> node click?</i>
 view.on(&quot;click&quot;, <b>function</b>(vw, index, node, e){
 alert('Node &quot;' + node.id + '&quot; at index: ' + index + &quot; was clicked.&quot;);
 });

 <i>// direct load of JSON data</i>
 view.load(&quot;foobar.php&quot;);


 <i>// Example from my blog list</i>
 <b>var</b> tpl = <b>new</b> Ext.Template(
 '&amp;lt;div class=&quot;entry&quot;&amp;gt;' +
 '&amp;lt;a class=&quot;entry-title&quot; href=&quot;{link}&quot;&amp;gt;{title}&amp;lt;/a&amp;gt;' +
 &quot;&amp;lt;h4&amp;gt;{date} by {author} | {comments} Comments&amp;lt;/h4&amp;gt;{description}&quot; +
 &quot;&amp;lt;/div&amp;gt;&amp;lt;hr /&amp;gt;&quot;
 );

 <b>var</b> moreView = <b>new</b> Ext.JsonView(&quot;entry-list&quot;, tpl, {
 jsonRoot: &quot;posts&quot;
 });
 moreView.on(&quot;beforerender&quot;, <b>this</b>.sortEntries, <b>this</b>);
 moreView.load({
 url:&quot;/blog/get-posts.php&quot;,
 params: &quot;allposts=true&quot;,
 text:&quot;Loading Blog Entries...&quot;
 });
 &lt;/code&gt;&lt;/pre&gt;
 * @constructor
 * Create a <b>new</b> JsonView
 * @param {String/HTMLElement/Element} container The container element where the view is to be rendered.
 * @param {Template} tpl The rendering template
 * @param {Object} config The config object
 */</i>
Ext.JsonView = <b>function</b>(container, tpl, config){
    Ext.JsonView.superclass.constructor.call(<b>this</b>, container, tpl, config);

    <b>var</b> um = <b>this</b>.el.getUpdateManager();
    um.setRenderer(<b>this</b>);
    um.on(&quot;update&quot;, <b>this</b>.onLoad, <b>this</b>);
    um.on(&quot;failure&quot;, <b>this</b>.onLoadException, <b>this</b>);

    <i>/**
     * @event beforerender
     * Fires before rendering of the downloaded json data.
     * @param {Ext.View} <b>this</b>
     * @param {Object} data The json data loaded
     */</i>
    <b>this</b>.events[&quot;beforerender&quot;] = true;
    <i>/**
     * @event load
     * Fires when data is loaded.
     * @param {Ext.View} <b>this</b>
     * @param {Object} data The json data loaded
     * @param {Object} response The raw Connect response object
     */</i>
    <b>this</b>.events[&quot;load&quot;] = true;
    <i>/**
     * @event loadexception
     * Fires when loading fails.
     * @param {Ext.View} <b>this</b>
     * @param {Object} response The raw Connect response object
     */</i>
    <b>this</b>.events[&quot;loadexception&quot;] = true;
};
Ext.extend(Ext.JsonView, Ext.View, {
    <i>/**
     * The root property <b>in</b> the loaded json object that contains the data
     * @type {String}
     */</i>
    jsonRoot : &quot;&quot;,

    <i>/**
     * Refreshes the view.
     */</i>
    refresh : <b>function</b>(){
        <b>this</b>.clearSelections();
        <b>this</b>.el.update(&quot;&quot;);
        <b>var</b> html = [];
        <b>var</b> o = <b>this</b>.jsonData;
        <b>if</b>(o &amp;&amp; o.length &gt; 0){
            <b>for</b>(var i = 0, len = o.length; i &lt; len; i++){
                <b>var</b> data = <b>this</b>.prepareData(o[i], i, o);
                html[html.length] = <b>this</b>.tpl.apply(data);
            }
        }<b>else</b>{
            html.push(<b>this</b>.emptyText);
        }
        <b>this</b>.el.update(html.join(&quot;&quot;));
        <b>this</b>.nodes = <b>this</b>.el.dom.childNodes;
        <b>this</b>.updateIndexes(0);
    },

    <i>/**
     * Performs an async request, loading the JSON from the response. If params are specified it uses POST, otherwise it uses GET.
     * @param {Object/String/Function} url The url <b>for</b> this request or a <b>function</b> to call to get the url or a config object containing any of the following options:
     &lt;pre&gt;&lt;code&gt;
     view.load({
     url: &quot;your-url.php&quot;,&lt;br/&gt;
     params: {param1: &quot;foo&quot;, param2: &quot;bar&quot;}, <i>// or a URL encoded string&lt;br/&gt;</i>
     callback: yourFunction,&lt;br/&gt;
     scope: yourObject, <i>//(optional scope)  &lt;br/&gt;</i>
     discardUrl: false, &lt;br/&gt;
     nocache: false,&lt;br/&gt;
     text: &quot;Loading...&quot;,&lt;br/&gt;
     timeout: 30,&lt;br/&gt;
     scripts: false&lt;br/&gt;
     });
     &lt;/code&gt;&lt;/pre&gt;
     * The only required property is url. The optional properties nocache, text and scripts
     * are shorthand <b>for</b> disableCaching, indicatorText and loadScripts and are used to set their associated property on <b>this</b> UpdateManager instance.
     * @param {String/Object} params (optional) The parameters to pass as either a url encoded string &quot;param1=1&amp;amp;param2=2&quot; or an object {param1: 1, param2: 2}
     * @param {Function} callback (optional) Callback when transaction is complete - called <b>with</b> signature (oElement, bSuccess)
     * @param {Boolean} discardUrl (optional) By <b>default</b> when you execute an update the defaultUrl is changed to the last used url. If true, it will not store the url.
     */</i>
    load : <b>function</b>(){
        <b>var</b> um = <b>this</b>.el.getUpdateManager();
        um.update.apply(um, arguments);
    },

    render : <b>function</b>(el, response){
        <b>this</b>.clearSelections();
        <b>this</b>.el.update(&quot;&quot;);
        <b>var</b> o;
        try{
            o = Ext.util.JSON.decode(response.responseText);
            <b>if</b>(this.jsonRoot){
                o = eval(&quot;o.&quot; + <b>this</b>.jsonRoot);
            }
        } catch(e){
        }
        <i>/**
         * The current json data or null
         */</i>
        <b>this</b>.jsonData = o;
        <b>this</b>.beforeRender();
        <b>this</b>.refresh();
    },

<i>/**
 * Get the number of records <b>in</b> the current JSON dataset
 * @<b>return</b> {Number}
 */</i>
    getCount : <b>function</b>(){
        <b>return</b> this.jsonData ? <b>this</b>.jsonData.length : 0;
    },

<i>/**
 * Returns the JSON object <b>for</b> the specified node(s)
 * @param {HTMLElement/Array} node The node or an array of nodes
 * @<b>return</b> {Object/Array} If you pass <b>in</b> an array, you get an array back, otherwise
 * you get the JSON object <b>for</b> the node
 */</i>
    getNodeData : <b>function</b>(node){
        <b>if</b>(node instanceof Array){
            <b>var</b> data = [];
            <b>for</b>(var i = 0, len = node.length; i &lt; len; i++){
                data.push(<b>this</b>.getNodeData(node[i]));
            }
            <b>return</b> data;
        }
        <b>return</b> this.jsonData[<b>this</b>.indexOf(node)] || null;
    },

    beforeRender : <b>function</b>(){
        <b>this</b>.snapshot = <b>this</b>.jsonData;
        <b>if</b>(this.sortInfo){
            <b>this</b>.sort.apply(<b>this</b>, <b>this</b>.sortInfo);
        }
        <b>this</b>.fireEvent(&quot;beforerender&quot;, <b>this</b>, <b>this</b>.jsonData);
    },

    onLoad : <b>function</b>(el, o){
        <b>this</b>.fireEvent(&quot;load&quot;, <b>this</b>, <b>this</b>.jsonData, o);
    },

    onLoadException : <b>function</b>(el, o){
        <b>this</b>.fireEvent(&quot;loadexception&quot;, <b>this</b>, o);
    },

<i>/**
 * Filter the data by a specific property.
 * @param {String} property A property on your JSON objects
 * @param {String/RegExp} value Either string that the property values
 * should start <b>with</b> or a RegExp to test against the property
 */</i>
    filter : <b>function</b>(property, value){
        <b>if</b>(this.jsonData){
            <b>var</b> data = [];
            <b>var</b> ss = <b>this</b>.snapshot;
            <b>if</b>(typeof value == &quot;string&quot;){
                <b>var</b> vlen = value.length;
                <b>if</b>(vlen == 0){
                    <b>this</b>.clearFilter();
                    <b>return</b>;
                }
                value = value.toLowerCase();
                <b>for</b>(var i = 0, len = ss.length; i &lt; len; i++){
                    <b>var</b> o = ss[i];
                    <b>if</b>(o[property].substr(0, vlen).toLowerCase() == value){
                        data.push(o);
                    }
                }
            } <b>else</b> if(value.exec){ <i>// regex?</i>
                <b>for</b>(var i = 0, len = ss.length; i &lt; len; i++){
                    <b>var</b> o = ss[i];
                    <b>if</b>(value.test(o[property])){
                        data.push(o);
                    }
                }
            } <b>else</b>{
                <b>return</b>;
            }
            <b>this</b>.jsonData = data;
            <b>this</b>.refresh();
        }
    },

<i>/**
 * Filter by a <b>function</b>. The passed <b>function</b> will be called <b>with</b> each
 * object <b>in</b> the current dataset. If the <b>function</b> returns true, the value is kept
 * otherwise it is filtered.
 * @param {Function} fn
 * @param {Object} scope (optional) The scope of the <b>function</b> (defaults to <b>this</b> JsonView)
 */</i>
    filterBy : <b>function</b>(fn, scope){
        <b>if</b>(this.jsonData){
            <b>var</b> data = [];
            <b>var</b> ss = <b>this</b>.snapshot;
            <b>for</b>(var i = 0, len = ss.length; i &lt; len; i++){
                <b>var</b> o = ss[i];
                <b>if</b>(fn.call(scope || <b>this</b>, o)){
                    data.push(o);
                }
            }
            <b>this</b>.jsonData = data;
            <b>this</b>.refresh();
        }
    },

<i>/**
 * Clears the current filter.
 */</i>
    clearFilter : <b>function</b>(){
        <b>if</b>(this.snapshot &amp;&amp; <b>this</b>.jsonData != <b>this</b>.snapshot){
            <b>this</b>.jsonData = <b>this</b>.snapshot;
            <b>this</b>.refresh();
        }
    },


<i>/**
 * Sorts the data <b>for</b> this view and refreshes it.
 * @param {String} property A property on your JSON objects to sort on
 * @param {String} direction (optional) desc or asc (defaults to asc)
 * @param {Function} sortType (optional) A <b>function</b> to call to convert the data to a sortable value.
 */</i>
    sort : <b>function</b>(property, dir, sortType){
        <b>this</b>.sortInfo = Array.prototype.slice.call(arguments, 0);
        <b>if</b>(this.jsonData){
            <b>var</b> p = property;
            <b>var</b> dsc = dir &amp;&amp; dir.toLowerCase() == &quot;desc&quot;;
            <b>var</b> f = <b>function</b>(o1, o2){
                <b>var</b> v1 = sortType ? sortType(o1[p]) : o1[p];
                <b>var</b> v2 = sortType ? sortType(o2[p]) : o2[p];
                ;
                <b>if</b>(v1 &lt; v2){
                    <b>return</b> dsc ? +1 : -1;
                } <b>else</b> if(v1 &gt; v2){
                    <b>return</b> dsc ? -1 : +1;
                } <b>else</b>{
                    <b>return</b> 0;
                }
            };
            <b>this</b>.jsonData.sort(f);
            <b>this</b>.refresh();
            <b>if</b>(this.jsonData != <b>this</b>.snapshot){
                <b>this</b>.snapshot.sort(f);
            }
        }
    }
});</code></pre><hr><div style="font-size:10px;text-align:center;color:gray;">yui-ext - Copyright &copy; 2006 Jack Slocum.  |
    Yahoo! UI - Copyright &copy; 2006 Yahoo! Inc.<br />All rights reserved.</div>
    </body></html>