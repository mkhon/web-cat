<$comment
EO Template for use by "eogenerator" based upon MiscMerge engine.
BE SURE NOT TO INCLUDE DATES IN THIS FILE.$>/*==========================================================================*\
 |  <$GEN_PREFIX$><$classNameWithoutPackage$>.java
 |*-------------------------------------------------------------------------*|
 |  Created by eogenerator
 |  DO NOT EDIT.  Make changes to <$classNameWithoutPackage$>.java instead.
 |*-------------------------------------------------------------------------*|
 |  Copyright (C) 2006 Virginia Tech
 |
 |  This file is part of Web-CAT.
 |
 |  Web-CAT is free software; you can redistribute it and/or modify
 |  it under the terms of the GNU General Public License as published by
 |  the Free Software Foundation; either version 2 of the License, or
 |  (at your option) any later version.
 |
 |  Web-CAT is distributed in the hope that it will be useful,
 |  but WITHOUT ANY WARRANTY; without even the implied warranty of
 |  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 |  GNU General Public License for more details.
 |
 |  You should have received a copy of the GNU General Public License
 |  along with Web-CAT; if not, write to the Free Software
 |  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 |
 |  Project manager: Stephen Edwards <edwards@cs.vt.edu>
 |  Virginia Tech CS Dept, 660 McBryde Hall (0106), Blacksburg, VA 24061 USA
 \*==========================================================================*/

<$foreach package classPackage do$>package <$package$>;
<$endforeach do$>
import com.webobjects.foundation.*;
import com.webobjects.eocontrol.*;
import com.webobjects.eoaccess.*;
import java.util.Enumeration;
import org.apache.log4j.Logger;

// -------------------------------------------------------------------------
/**
 * An automatically generated EOGenericRecord subclass.  DO NOT EDIT.
 * To change, use EOModeler, or make additions in
 * <$classNameWithoutPackage$>.java.
 *
 * @author Generated by eogenerator
 * @version version suppressed to control auto-generation
 */
<$comment This is how to put in a custom EO superclass.  We also declare
this class as being abstract, since it should never be instantiated.
$>public abstract class <$GEN_PREFIX$><$classNameWithoutPackage$>
    extends <$if hasParentEntity$><$javaParentClassName$><$else$>er.extensions.ERXGenericRecord<$endif$>
<$foreach Attribute classAttributes.@sortedNameArray do$><$if Attribute.userInfo.isMutable == 'true'$>    implements net.sf.webcat.core.MutableContainer.MutableContainerOwner
<$break$><$endif$><$endforeach do$>{
    //~ Constructors ..........................................................

    // ----------------------------------------------------------
    /**
     * Creates a new <$GEN_PREFIX$><$classNameWithoutPackage$> object.
     */
    public <$GEN_PREFIX$><$classNameWithoutPackage$>()
    {
        super();
    }


    // ----------------------------------------------------------
    /**
     * A static factory method for creating a new
     * <$GEN_PREFIX$><$classNameWithoutPackage$> object given required
     * attributes and relationships.
     * @param editingContext The context in which the new object will be
     * inserted<$foreach Attribute classAttributes.@sortedNameArray do$><$if !Attribute.allowsNull$>
     * @param <$Attribute.name$><$endif$><$endforeach do$><$foreach ToOneRelationship classToOneRelationships.@sortedNameArray do$><$if ToOneRelationship.isMandatory$>
     * @param <$ToOneRelationship.name$><$endif$><$endforeach do$>
     * @return The newly created object
     */
    public static <$classNameWithoutPackage$> create(
        EOEditingContext editingContext<$foreach Attribute classAttributes.@sortedNameArray do$><$if !Attribute.allowsNull$>,
        <$if Attribute.userInfo.isScalar == 'true'$><$Attribute.userInfo.type$><$else$><$Attribute.javaValueClassName$><$endif$> <$Attribute.name$><$endif$><$endforeach do$><$foreach ToOneRelationship classToOneRelationships.@sortedNameArray do$><$if ToOneRelationship.isMandatory$>,
        <$ToOneRelationship.destinationEntity.referenceJavaClassName$> <$ToOneRelationship.name$><$endif$><$endforeach do$>
        )
    {
        <$classNameWithoutPackage$> eoObject = (<$classNameWithoutPackage$>)
            EOUtilities.createAndInsertInstance(
                editingContext,
                <$GEN_PREFIX$><$classNameWithoutPackage$>.ENTITY_NAME);<$foreach Attribute classAttributes.@sortedNameArray do$><$if !Attribute.allowsNull$>
        eoObject.set<$Attribute.name.initialCapitalString$>(<$Attribute.name$>);<$endif$><$endforeach do$><$foreach ToOneRelationship classToOneRelationships.@sortedNameArray do$><$if ToOneRelationship.isMandatory$>
        eoObject.set<$ToOneRelationship.name.initialCapitalString$>Relationship(<$ToOneRelationship.name$>);<$endif$><$endforeach do$>
        return eoObject;
    }


    // ----------------------------------------------------------
    /**
     * Get a local instance of the given object in another editing context.
     * @param editingContext The target editing context
     * @param eo The object to import
     * @return An instance of the given object in the target editing context
     */
    public static <$classNameWithoutPackage$> localInstance(
        EOEditingContext editingContext, <$classNameWithoutPackage$> eo)
    {
        return (eo == null)
            ? null
            : (<$classNameWithoutPackage$>)EOUtilities.localInstanceOfObject(
                editingContext, eo);
    }


    // ----------------------------------------------------------
    /**
     * Look up an object by id number.  Assumes the editing
     * context is appropriately locked.
     * @param ec The editing context to use
     * @param id The id to look up
     * @return The object, or null if no such id exists
     */
    public static <$classNameWithoutPackage$> forId(
        EOEditingContext ec, int id )
    {
        <$classNameWithoutPackage$> obj = null;
        if (id > 0)
        {
            NSArray results = EOUtilities.objectsMatchingKeyAndValue( ec,
                ENTITY_NAME, "id", new Integer( id ) );
            if ( results != null && results.count() > 0 )
            {
                obj = (<$classNameWithoutPackage$>)results.objectAtIndex( 0 );
            }
        }
        return obj;
    }


    // ----------------------------------------------------------
    /**
     * Look up an object by id number.  Assumes the editing
     * context is appropriately locked.
     * @param ec The editing context to use
     * @param id The id to look up
     * @return The object, or null if no such id exists
     */
    public static <$classNameWithoutPackage$> forId(
        EOEditingContext ec, String id )
    {
        return forId( ec, er.extensions.ERXValueUtilities.intValue( id ) );
    }


    //~ Constants (for key names) .............................................

<$comment

Some people like to have constant strings defined for each key. For an
attribute named fooBar, this will declare a FOO_BAR_KEY constant string.

$>    // Attributes ---<$foreach attribute classAttributes.@sortedNameArray do$>
    public static final String <$attribute.name.uppercaseUnderbarString$>_KEY = "<$attribute.name$>";<$endforeach$>
    // To-one relationships ---<$foreach rel classToOneRelationships.@sortedNameArray do$>
    public static final String <$rel.name.uppercaseUnderbarString$>_KEY = "<$rel.name$>";<$endforeach$>
    // To-many relationships ---<$foreach rel classToManyRelationships.@sortedNameArray do$>
    public static final String <$rel.name.uppercaseUnderbarString$>_KEY = "<$rel.name$>";<$endforeach$>
    // Fetch specifications ---<$foreach FetchSpec javaBeautifiedFetchSpecificationDictionaries.@sortedNameArray fetchspec$>
    public static final String <$FetchSpec.fetchName.uppercaseUnderbarString$>_FSPEC = "<$FetchSpec.fetchName$>";<$endforeach fetchspec$>
    public static final String ENTITY_NAME = "<$name$>";


    //~ Methods ...............................................................

    // ----------------------------------------------------------
    /**
     * Get a local instance of this object in another editing context.
     * @param editingContext The target editing context
     * @return An instance of this object in the target editing context
     */
    public <$classNameWithoutPackage$> localInstance(EOEditingContext editingContext)
    {
        return (<$classNameWithoutPackage$>)EOUtilities.localInstanceOfObject(
            editingContext, this);
    }


    // ----------------------------------------------------------
    /**
     * Get a list of changes between this object's current state and the
     * last committed version.
     * @return a dictionary of the changes that have not yet been committed
     */
    public NSDictionary changedProperties()
    {
        return changesFromSnapshot(
            editingContext().committedSnapshotForObject(this) );
    }


    // ----------------------------------------------------------
    /**
     * Retrieve this object's <code>id</code> value.
     * @return the value of the attribute
     */
    public Number id()
    {
        try
        {
            return (Number)EOUtilities.primaryKeyForObject(
                editingContext() , this ).objectForKey( "id" );
        }
        catch (Exception e)
        {
            return er.extensions.ERXConstant.ZeroInteger;
        }
    }

<$foreach Attribute classAttributes.@sortedNameArray do$><$if Attribute.userInfo.isMutable == 'true'$>    //-- Local mutable cache --
    private <$Attribute.userInfo.valueClassName$> <$Attribute.name$>Cache;
    private <$Attribute.javaValueClassName$> <$Attribute.name$>RawCache;

    // ----------------------------------------------------------
    /**
     * Retrieve this object's <code><$Attribute.name$></code> value.
     * @return the value of the attribute
     */
    public <$Attribute.userInfo.valueClassName$> <$Attribute.name$>()
    {
    	<$Attribute.javaValueClassName$> dbValue =
            (<$Attribute.javaValueClassName$>)storedValueForKey( "<$Attribute.name$>" );
        if ( <$Attribute.name$>RawCache != dbValue )
        {
            if ( dbValue != null && dbValue.equals( <$Attribute.name$>RawCache ) )
            {
                // They are still equal, so just update the raw cache
                <$Attribute.name$>RawCache = dbValue;
            }
            else
            {
                // Underlying attribute may have changed because
                // of a concurrent update through another editing
                // context, so throw away current values.
                <$Attribute.name$>RawCache = dbValue;
                <$Attribute.userInfo.valueClassName$> newValue =
                    <$Attribute.userInfo.valueClassName$>
                    .<$Attribute.userInfo.valueFactoryMethodName$>( dbValue );
                if ( <$Attribute.name$>Cache != null )
                {
                    <$Attribute.name$>Cache.copyFrom( newValue );
                }
                else
                {
                    <$Attribute.name$>Cache = newValue;
                }
                <$Attribute.name$>Cache.setOwner( this );
                setUpdateMutableFields( true );
            }
        }
        else if ( dbValue == null && <$Attribute.name$>Cache == null )
        {
            <$Attribute.name$>Cache =
                <$Attribute.userInfo.valueClassName$>
                .<$Attribute.userInfo.valueFactoryMethodName$>( dbValue );
             <$Attribute.name$>Cache.setOwner( this );
             setUpdateMutableFields( true );
        }
        return <$Attribute.name$>Cache;
    }


    // ----------------------------------------------------------
    /**
     * Change the value of this object's <code><$Attribute.name$></code>
     * property.
     *
     * @param value The new value for this property
     */
    public void set<$Attribute.name.initialCapitalString$>( <$Attribute.userInfo.valueClassName$> value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set<$Attribute.name.initialCapitalString$>("
                + value + ")" );
        }
        if ( <$Attribute.name$>Cache == null )
        {
            <$Attribute.name$>Cache = value;
            value.setHasChanged( false );
            <$Attribute.name$>RawCache = value.<$Attribute.userInfo.adaptorValueConversionMethodName$>();
            takeStoredValueForKey( <$Attribute.name$>RawCache, "<$Attribute.name$>" );
        }
        else if ( <$Attribute.name$>Cache != value )  // ( <$Attribute.name$>Cache != null )
        {
            <$Attribute.name$>Cache.copyFrom( value );
            setUpdateMutableFields( true );
        }
        else  // ( <$Attribute.name$>Cache == non-null value )
        {
            // no nothing
        }
    }


    // ----------------------------------------------------------
    /**
     * Clear the value of this object's <code><$Attribute.name$></code>
     * property.
     */
    public void clear<$Attribute.name.initialCapitalString$>()
    {
        if (log.isDebugEnabled())
        {
            log.debug( "clear<$Attribute.name.initialCapitalString$>()" );
        }
        takeStoredValueForKey( null, "<$Attribute.name$>" );
        <$Attribute.name$>RawCache = null;
        <$Attribute.name$>Cache = null;
    }


<$else$><$if Attribute.userInfo.isScalar == 'true'$>    // ----------------------------------------------------------
    /**
     * Retrieve this object's <code><$Attribute.name$></code> value.
     * @return the value of the attribute
     */
    public <$Attribute.userInfo.type$> <$Attribute.name$>()
    {
        <$Attribute.javaValueClassName$> result =
            (<$Attribute.javaValueClassName$>)storedValueForKey( "<$Attribute.name$>" );
        return ( result == null )
            ? <$Attribute.userInfo.scalarDefault$>
            : <$if Attribute.userInfo.type == 'boolean'$>( result.intValue() > 0 )<$else$>result.<$Attribute.userInfo.scalarConversionMethodName$>()<$endif$>;
    }


    // ----------------------------------------------------------
    /**
     * Change the value of this object's <code><$Attribute.name$></code>
     * property.
     *
     * @param value The new value for this property
     */
    public void set<$Attribute.name.initialCapitalString$>( <$Attribute.userInfo.type$> value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set<$Attribute.name.initialCapitalString$>("
                + value + "): was " + <$Attribute.name$>() );
        }
        <$Attribute.javaValueClassName$> actual =
<$if Attribute.userInfo.type == 'boolean'$>            er.extensions.ERXConstant.integerForInt( value ? 1 : 0 );
<$elseif Attribute.userInfo.type == 'int'
      || Attribute.userInfo.type == 'byte'
      || Attribute.userInfo.type == 'short'$>            er.extensions.ERXConstant.integerForInt( value );
<$else$>            new <$Attribute.userInfo.valueClassName$>( value );
<$endif$>        set<$Attribute.name.initialCapitalString$>Raw( actual );
    }


<$endif$>    // ----------------------------------------------------------
    /**
     * Retrieve this object's <code><$Attribute.name$></code> value.
     * @return the value of the attribute
     */
    public <$Attribute.javaValueClassName$> <$Attribute.name$><$if Attribute.userInfo.isScalar == 'true'$>Raw<$endif$>()
    {
        return (<$Attribute.javaValueClassName$>)storedValueForKey( "<$Attribute.name$>" );
    }


    // ----------------------------------------------------------
    /**
     * Change the value of this object's <code><$Attribute.name$></code>
     * property.
     *
     * @param value The new value for this property
     */
    public void set<$Attribute.name.initialCapitalString$><$if Attribute.userInfo.isScalar == 'true'$>Raw<$endif$>( <$Attribute.javaValueClassName$> value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set<$Attribute.name.initialCapitalString$><$if Attribute.userInfo.isScalar == 'true'$>Raw<$endif$>("
                + value + "): was " + <$Attribute.name$><$if Attribute.userInfo.isScalar == 'true'$>Raw<$endif$>() );
        }
        takeStoredValueForKey( value, "<$Attribute.name$>" );
    }


<$endif$><$endforeach do$><$foreach Attribute classAttributes.@sortedNameArray hasMutables$><$if Attribute.userInfo.isMutable == 'true'$>    // ----------------------------------------------------------
    /**
     * Called just before this object is saved to the database.
     */
    public void saveMutables()
    {
        log.debug("saveMutables()");
<$foreach Attribute classAttributes.@sortedNameArray willUpdate$><$if Attribute.userInfo.isMutable == 'true'$>        if ( <$Attribute.name$>Cache != null
            && <$Attribute.name$>Cache.hasChanged() )
        {
            <$Attribute.name$>RawCache = <$Attribute.name$>Cache.<$Attribute.userInfo.adaptorValueConversionMethodName$>();
            takeStoredValueForKey( <$Attribute.name$>RawCache, "<$Attribute.name$>" );
            <$Attribute.name$>Cache.setHasChanged( false );
        }
<$endif$><$endforeach willUpdate$>
        setUpdateMutableFields( false );
    }


    // ----------------------------------------------------------
    /**
     * Called just before this object is saved to the database.
     */
    public void willUpdate()
    {
        log.debug("willUpdate()");
        saveMutables();
        super.willUpdate();
    }


    // ----------------------------------------------------------
    /**
     * Called just before this object is inserted into the database.
     */
    public void willInsert()
    {
        log.debug("willInsert()");
        saveMutables();
        super.willInsert();
    }


    // ----------------------------------------------------------
    /**
     * Called when the object is invalidated.
     */
    public void flushCaches()
    {
        log.debug("flushCaches()");
<$foreach Attribute classAttributes.@sortedNameArray flushCache$><$if Attribute.userInfo.isMutable == 'true'$>        <$Attribute.name$>Cache = null;
        <$Attribute.name$>RawCache  = null;
<$endif$><$endforeach flushCache$>        setUpdateMutableFields( false );
        super.flushCaches();
    }


    // ----------------------------------------------------------
    /**
     * Called when an owned mutable container object is changed.
     */
    public void mutableContainerHasChanged()
    {
        setUpdateMutableFields( true );
    }


<$break$><$endif$><$endforeach hasMutables$><$comment
Add methods to call named fetch specifications, with any qualifier bindings having typed
parameters.

$><$foreach ToOneRelationship classToOneRelationships.@sortedNameArray toonerels$>    // ----------------------------------------------------------
    /**
     * Retrieve the entity pointed to by the <code><$ToOneRelationship.name$></code>
     * relationship.
     * @return the entity in the relationship
     */
    public <$ToOneRelationship.destinationEntity.referenceJavaClassName$> <$ToOneRelationship.name$>()
    {
        return (<$ToOneRelationship.destinationEntity.referenceJavaClassName$>)storedValueForKey( "<$ToOneRelationship.name$>" );
    }


    // ----------------------------------------------------------
    /**
     * Set the entity pointed to by the <code><$ToOneRelationship.name$></code>
     * relationship (DO NOT USE--instead, use
     * <code>set<$ToOneRelationship.name.initialCapitalString$>Relationship()</code>.
     * This method is provided for WebObjects use.
     *
     * @param value The new entity to relate to
     */
    public void set<$ToOneRelationship.name.initialCapitalString$>( <$ToOneRelationship.destinationEntity.referenceJavaClassName$> value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set<$ToOneRelationship.name.initialCapitalString$>("
                + value + "): was " + <$ToOneRelationship.name$>() );
        }
        takeStoredValueForKey( value, "<$ToOneRelationship.name$>" );
    }


<$comment

The following method is better than using addObjectToBothSidesOf-
RelationshipWithKey directly because you will get compile time type
checking instead of runtime checking (plus you don't risk typos in
constant strings of key names).
$>    // ----------------------------------------------------------
    /**
     * Set the entity pointed to by the <code><$ToOneRelationship.name$></code>
     * relationship.  This method is a type-safe version of
     * <code>addObjectToBothSidesOfRelationshipWithKey()</code>.
     *
     * @param value The new entity to relate to
     */
    public void set<$ToOneRelationship.name.initialCapitalString$>Relationship(
        <$ToOneRelationship.destinationEntity.referenceJavaClassName$> value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set<$ToOneRelationship.name.initialCapitalString$>Relationship("
                + value + "): was " + <$ToOneRelationship.name$>() );
        }
        if ( value == null )
        {
            <$ToOneRelationship.destinationEntity.referenceJavaClassName$> object = <$ToOneRelationship.name$>();
            if ( object != null )
                removeObjectFromBothSidesOfRelationshipWithKey( object, "<$ToOneRelationship.name$>" );
        }
        else
        {
            addObjectToBothSidesOfRelationshipWithKey( value, "<$ToOneRelationship.name$>" );
        }
    }


<$endforeach toonerels$><$foreach ToManyRelationship classToManyRelationships.@sortedNameArray tomanyrels$>    // ----------------------------------------------------------
    /**
     * Retrieve the entities pointed to by the <code><$ToManyRelationship.name$></code>
     * relationship.
     * @return an NSArray of the entities in the relationship
     */
    public NSArray <$ToManyRelationship.name$>()
    {
        return (NSArray)storedValueForKey( "<$ToManyRelationship.name$>" );
    }


    // ----------------------------------------------------------
    /**
     * Replace the list of entities pointed to by the
     * <code><$ToManyRelationship.name$></code> relationship.
     *
     * @param value The new set of entities to relate to
     */
    public void set<$ToManyRelationship.name.initialCapitalString$>( NSMutableArray value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set<$ToManyRelationship.name.initialCapitalString$>("
                + value + "): was " + <$ToManyRelationship.name$>() );
        }
        takeStoredValueForKey( value, "<$ToManyRelationship.name$>" );
    }


    // ----------------------------------------------------------
    /**
     * Add a new entity to the <code><$ToManyRelationship.name$></code>
     * relationship (DO NOT USE--instead, use
     * <code>addTo<$ToManyRelationship.name.initialCapitalString$>Relationship()</code>.
     * This method is provided for WebObjects use.
     *
     * @param value The new entity to relate to
     */
    public void addTo<$ToManyRelationship.name.initialCapitalString$>( <$ToManyRelationship.destinationEntity.referenceJavaClassName$> value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "addTo<$ToManyRelationship.name.initialCapitalString$>("
                + value + "): was " + <$ToManyRelationship.name$>() );
        }
        NSMutableArray array = (NSMutableArray)<$ToManyRelationship.name$>();
        willChange();
        array.addObject( value );
    }


    // ----------------------------------------------------------
    /**
     * Remove a specific entity from the <code><$ToManyRelationship.name$></code>
     * relationship (DO NOT USE--instead, use
     * <code>removeFrom<$ToManyRelationship.name.initialCapitalString$>Relationship()</code>.
     * This method is provided for WebObjects use.
     *
     * @param value The entity to remove from the relationship
     */
    public void removeFrom<$ToManyRelationship.name.initialCapitalString$>( <$ToManyRelationship.destinationEntity.referenceJavaClassName$> value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "RemoveFrom<$ToManyRelationship.name.initialCapitalString$>("
                + value + "): was " + <$ToManyRelationship.name$>() );
        }
        NSMutableArray array = (NSMutableArray)<$ToManyRelationship.name$>();
        willChange();
        array.removeObject( value );
    }


<$comment

The following adds typed methods to add or remove an object from a to-many relationship.
This is better than using addObjectToBothSidesOfRelationshipWithKey directly because
you will get compile time type checking instead of runtime checking, and you avoid the
possibility of making a typo in the key name.
$>    // ----------------------------------------------------------
    /**
     * Add a new entity to the <code><$ToManyRelationship.name$></code>
     * relationship.
     *
     * @param value The new entity to relate to
     */
    public void addTo<$ToManyRelationship.name.initialCapitalString$>Relationship( <$ToManyRelationship.destinationEntity.referenceJavaClassName$> value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "addTo<$ToManyRelationship.name.initialCapitalString$>Relationship("
                + value + "): was " + <$ToManyRelationship.name$>() );
        }
        addObjectToBothSidesOfRelationshipWithKey(
            value, "<$ToManyRelationship.name$>" );
    }


    // ----------------------------------------------------------
    /**
     * Remove a specific entity from the <code><$ToManyRelationship.name$></code>
     * relationship.
     *
     * @param value The entity to remove from the relationship
     */
    public void removeFrom<$ToManyRelationship.name.initialCapitalString$>Relationship( <$ToManyRelationship.destinationEntity.referenceJavaClassName$> value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "removeFrom<$ToManyRelationship.name.initialCapitalString$>Relationship("
                + value + "): was " + <$ToManyRelationship.name$>() );
        }
        removeObjectFromBothSidesOfRelationshipWithKey(
            value, "<$ToManyRelationship.name$>" );
    }


<$comment

The following adds typed methods to create, and delete objects from a to-many relationship.
The main difference in the delete mechanism, versus the removeFrom... method above is that
this delete method will remove the object from the editing context if it is we do not own
its destination.  The user can override these methods in the subclass to provide additional
functionality on these methods.
$>    // ----------------------------------------------------------
    /**
     * Create a brand new object that is a member of the
     * <code><$ToManyRelationship.name$></code> relationship.
     *
     * @return The new entity
     */
    public <$ToManyRelationship.destinationEntity.referenceJavaClassName$> create<$ToManyRelationship.name.initialCapitalString$>Relationship()
    {
        if (log.isDebugEnabled())
        {
            log.debug( "create<$ToManyRelationship.name.initialCapitalString$>Relationship()" );
        }
        EOClassDescription eoClassDesc = EOClassDescription
            .classDescriptionForEntityName( "<$ToManyRelationship.destinationEntity.name$>" );
        EOEnterpriseObject eoObject = eoClassDesc
            .createInstanceWithEditingContext( editingContext(), null );
        editingContext().insertObject( eoObject );
        addObjectToBothSidesOfRelationshipWithKey(
            eoObject, "<$ToManyRelationship.name$>" );
        return (<$ToManyRelationship.destinationEntity.referenceJavaClassName$>)eoObject;
    }


    // ----------------------------------------------------------
    /**
     * Remove<$ if !ToManyRelationship.ownsDestination$> and then delete<$endif$> a specific entity that is a member of the
     * <code><$ToManyRelationship.name$></code> relationship.
     *
     * @param value The entity to remove from the relationship<$ if !ToManyRelationship.ownsDestination$> and then delete<$endif$>
     */
    public void delete<$ToManyRelationship.name.initialCapitalString$>Relationship( <$ToManyRelationship.destinationEntity.referenceJavaClassName$> value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "delete<$ToManyRelationship.name.initialCapitalString$>Relationship("
                + value + "): was " + <$ToManyRelationship.name$>() );
        }
        removeObjectFromBothSidesOfRelationshipWithKey(
            value, "<$ToManyRelationship.name$>" );<$
if !ToManyRelationship.ownsDestination$>
        editingContext().deleteObject( value );<$endif$>
    }


    // ----------------------------------------------------------
    /**
     * Remove (and then delete, if owned) all entities that are members of the
     * <code><$ToManyRelationship.name$></code> relationship.
     */
    public void deleteAll<$ToManyRelationship.name.initialCapitalString$>Relationships()
    {
        if (log.isDebugEnabled())
        {
            log.debug( "deleteAll<$ToManyRelationship.name.initialCapitalString$>Relationships(): was "
                + <$ToManyRelationship.name$>() );
        }
        Enumeration objects = <$ToManyRelationship.name$>().objectEnumerator();
        while ( objects.hasMoreElements() )
            delete<$ToManyRelationship.name.initialCapitalString$>Relationship(
                (<$ToManyRelationship.destinationEntity.referenceJavaClassName$>)objects.nextElement() );
    }


<$endforeach tomanyrels$><$foreach FetchSpec javaBeautifiedFetchSpecificationDictionaries.@sortedNameArray fetchspec$>    // ----------------------------------------------------------
    /**
     * Retrieve object according to the <code><$FetchSpec.niceName$></code>
     * fetch specification.
     *
     * @param context The editing context to use<$foreach Binding FetchSpec.bindings do2$>
     * @param <$Binding.name$>Binding fetch spec parameter<$endforeach do2$>
     * @return an NSArray of the entities retrieved
     */
    public static NSArray objectsFor<$FetchSpec.niceName$>(
            EOEditingContext context<$foreach Binding FetchSpec.bindings do2$>,
            <$Binding.codeType$><$Binding.name$>Binding<$endforeach do2$>
        )
    {
        EOFetchSpecification spec = EOFetchSpecification
            .fetchSpecificationNamed( "<$FetchSpec.fetchName$>", "<$name$>" );
<$if FetchSpec.bindings.@count > 0$>
        NSMutableDictionary bindings = new NSMutableDictionary();
<$foreach Binding FetchSpec.bindings do2$>
        if ( <$Binding.name$>Binding != null )
            bindings.setObjectForKey( <$Binding.name$>Binding,
                                      "<$Binding.name$>" );<$endforeach do2$>
        spec = spec.fetchSpecificationWithQualifierBindings( bindings );
<$endif$>
        NSArray result = context.objectsWithFetchSpecification( spec );
        if (log.isDebugEnabled())
        {
            log.debug( "objectsFor<$FetchSpec.niceName$>(ec"
            <$foreach Binding FetchSpec.bindings do2$>
                + ", " + <$Binding.name$>Binding<$endforeach do2$>
                + "): " + result );
        }
        return result;
    }


<$endforeach fetchspec$>    //~ Instance/static variables .............................................

    static Logger log = Logger.getLogger( <$classNameWithoutPackage$>.class );
}
