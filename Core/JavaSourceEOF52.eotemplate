#*
   EO Template for use by the Velocity EOGenerator built into WOLips.
   BE SURE NOT TO INCLUDE DATES IN THIS FILE.
*#/*==========================================================================*\
 |  ${entity.prefixClassNameWithoutPackage}.java
 |*-------------------------------------------------------------------------*|
 |  Created by eogenerator
 |  DO NOT EDIT.  Make changes to ${entity.classNameWithoutPackage}.java instead.
 |*-------------------------------------------------------------------------*|
 |  Copyright (C) 2006-2009 Virginia Tech
 |
 |  This file is part of Web-CAT.
 |
 |  Web-CAT is free software; you can redistribute it and/or modify
 |  it under the terms of the GNU Affero General Public License as published
 |  by the Free Software Foundation; either version 3 of the License, or
 |  (at your option) any later version.
 |
 |  Web-CAT is distributed in the hope that it will be useful,
 |  but WITHOUT ANY WARRANTY; without even the implied warranty of
 |  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 |  GNU General Public License for more details.
 |
 |  You should have received a copy of the GNU Affero General Public License
 |  along with Web-CAT; if not, see <http://www.gnu.org/licenses/>.
\*==========================================================================*/

#if ($entity.superclassPackageName)
package $entity.superclassPackageName;

#end
import com.webobjects.eoaccess.*;
import com.webobjects.eocontrol.*;
import com.webobjects.foundation.*;
import er.extensions.eof.ERXKey;
import java.util.Enumeration;
import org.apache.log4j.Logger;

// -------------------------------------------------------------------------
/**
 * An automatically generated EOGenericRecord subclass.  DO NOT EDIT.
 * To change, use EOModeler, or make additions in
 * ${entity.classNameWithoutPackage}.java.
 *
 * @author Generated by eogenerator
 * @version version suppressed to control auto-generation
 */
#*
   This is how to put in a custom EO superclass.  We also declare
   this class as being abstract, since it should never be instantiated.
*#public abstract class ${entity.prefixClassNameWithoutPackage}
    extends #if ($entity.parentSet)${entity.parent.className}
#{else}er.extensions.eof.ERXGenericRecord
#end
#set ($alreadyFoundMutableAttribute = false)
#foreach ($attribute in $entity.sortedClassAttributes)
#if ($attribute.userInfo.isMutable && !$alreadyFoundMutableAttribute)
    implements net.sf.webcat.core.MutableContainer.MutableContainerOwner
#set ($alreadyFoundMutableAttribute = true)
#end
#end
#set ($alreadyFoundMigratoryAttribute = false)
#foreach ($attribute in $entity.sortedClassAttributes)
#if ($attribute.userInfo.needsMigration && !$alreadyFoundMigratoryAttribute)
    implements net.sf.webcat.core.MigratoryAttributeOwner
#set ($alreadyFoundMigratoryAttribute = true)
#end
#end
{
    //~ Constructors ..........................................................

    // ----------------------------------------------------------
    /**
     * Creates a new ${entity.prefixClassNameWithoutPackage} object.
     */
    public ${entity.prefixClassNameWithoutPackage}()
    {
        super();
    }


#if (!$entity.abstractEntity)
    // ----------------------------------------------------------
    /**
     * A static factory method for creating a new
     * ${entity.classNameWithoutPackage} object given required
     * attributes and relationships.
     * @param editingContext The context in which the new object will be
     * inserted
#foreach ($attribute in $entity.sortedClassAttributes)
#if (!$attribute.allowsNull)
     * @param ${attribute.name}
#end
#end
#foreach ($relationship in $entity.sortedClassToOneRelationships)
#if ($relationship.mandatory)
     * @param ${relationship.name}
#end
#end
     * @return The newly created object
     */
    public static ${entity.classNameWithoutPackage} create(
        EOEditingContext editingContext#foreach ($attribute in $entity.sortedClassAttributes)#if (!$attribute.allowsNull),
        #if ($attribute.userInfo.isScalar)${attribute.userInfo.type}#else${attribute.javaClassName}#end ${attribute.name}#end
#end#foreach ($relationship in $entity.sortedClassToOneRelationships)#if ($relationship.mandatory),
        ${relationship.actualDestination.classNameWithDefault} ${relationship.name}#end#end

        )
    {
        ${entity.classNameWithoutPackage} eoObject = (${entity.classNameWithoutPackage})
            EOUtilities.createAndInsertInstance(
                editingContext,
                ${entity.prefixClassNameWithoutPackage}.ENTITY_NAME);
#foreach ($attribute in $entity.sortedClassAttributes)
#if (!$attribute.allowsNull)
        eoObject.set${attribute.capitalizedName}(${attribute.name});
#end
#end
#foreach ($relationship in $entity.sortedClassToOneRelationships)
#if ($relationship.mandatory)
        eoObject.set${relationship.capitalizedName}Relationship(${relationship.name});
#end
#end
        return eoObject;
    }


    // ----------------------------------------------------------
    /**
     * Get a local instance of the given object in another editing context.
     * @param editingContext The target editing context
     * @param eo The object to import
     * @return An instance of the given object in the target editing context
     */
    public static ${entity.classNameWithoutPackage} localInstance(
        EOEditingContext editingContext, ${entity.classNameWithoutPackage} eo)
    {
        return (eo == null)
            ? null
            : (${entity.classNameWithoutPackage})EOUtilities.localInstanceOfObject(
                editingContext, eo);
    }


    // ----------------------------------------------------------
    /**
     * Look up an object by id number.  Assumes the editing
     * context is appropriately locked.
     * @param ec The editing context to use
     * @param id The id to look up
     * @return The object, or null if no such id exists
     */
    public static ${entity.classNameWithoutPackage} forId(
        EOEditingContext ec, int id )
    {
        ${entity.classNameWithoutPackage} obj = null;
        if (id > 0)
        {
            NSArray<${entity.classNameWithoutPackage}> results =
                objectsMatchingValues(ec, "id", new Integer(id));
            if (results != null && results.count() > 0)
            {
                obj = results.objectAtIndex(0);
            }
        }
        return obj;
    }


    // ----------------------------------------------------------
    /**
     * Look up an object by id number.  Assumes the editing
     * context is appropriately locked.
     * @param ec The editing context to use
     * @param id The id to look up
     * @return The object, or null if no such id exists
     */
    public static ${entity.classNameWithoutPackage} forId(
        EOEditingContext ec, String id )
    {
        return forId( ec, er.extensions.foundation.ERXValueUtilities.intValue( id ) );
    }


#end
    //~ Constants (for key names) .............................................
#*

  Some people like to have constant strings defined for each key. For an
  attribute named fooBar, this will declare a FOO_BAR_KEY constant string.

*#
#if ($entity.abstractEntity)
    // Relationship to base slice ---
    private static final String BASE_PREFIX = "${entity.initialLowercaseName}";
    private static final String BASE_PREFIX_DOT = BASE_PREFIX + ".";
#end
    // Attributes ---
#foreach ($attribute in $entity.sortedClassAttributes)
#if (!$attribute.inherited)
#if (!$entity.abstractEntity)
    public static final String ${attribute.uppercaseUnderscoreName}_KEY = "${attribute.name}";
#else
    public static final String ${attribute.uppercaseUnderscoreName}_KEY = BASE_PREFIX_DOT + "${attribute.name$}";
#end
    public static final ERXKey<${attribute.javaClassName}> ${attribute.name} =
        new ERXKey<${attribute.javaClassName}>(${attribute.uppercaseUnderscoreName}_KEY);
#end
#end
    // To-one relationships ---
#foreach ($rel in $entity.sortedClassToOneRelationships)
#if (!$rel.inherited)
#if (!$entity.abstractEntity)
    public static final String ${rel.uppercaseUnderscoreName}_KEY = "${rel.name}";
#else
    public static final String ${rel.uppercaseUnderscoreName}_KEY = BASE_PREFIX_DOT + "${rel.name}";
#end
    public static final ERXKey<${rel.actualDestination.classNameWithDefault}> ${rel.name} =
        new ERXKey<${rel.actualDestination.classNameWithDefault}>(${rel.uppercaseUnderscoreName}_KEY);
#end
#end
    // To-many relationships ---
#foreach ($rel in $entity.sortedClassToManyRelationships)
#if (!$rel.inherited)
#if (!$entity.abstractEntity)
    public static final String ${rel.uppercaseUnderscoreName}_KEY = "${rel.name}";
#else
    public static final String ${rel.uppercaseUnderscoreName}_KEY = BASE_PREFIX_DOT + "${rel.name}";
#end
    public static final ERXKey<${rel.actualDestination.classNameWithDefault}> ${rel.name} =
        new ERXKey<${rel.actualDestination.classNameWithDefault}>(${rel.uppercaseUnderscoreName}_KEY);
#end
#end
    // Fetch specifications ---
#foreach ($fetchSpec in $entity.sortedFetchSpecs)
    public static final String ${fetchSpec.uppercaseUnderscoreName}_FSPEC = "${fetchSpec.name}";
#end
#if (!$entity.abstractEntity)
    public static final String ENTITY_NAME = "${entity.name}";
#end


    //~ Methods ...............................................................

    // ----------------------------------------------------------
    /**
     * Get a local instance of this object in another editing context.
     * @param editingContext The target editing context
     * @return An instance of this object in the target editing context
     */
    public ${entity.classNameWithoutPackage} localInstance(EOEditingContext editingContext)
    {
        return (${entity.classNameWithoutPackage})EOUtilities.localInstanceOfObject(
            editingContext, this);
    }


#if (!$entity.parentSet)
    // ----------------------------------------------------------
    /**
     * Get a list of changes between this object's current state and the
     * last committed version.
     * @return a dictionary of the changes that have not yet been committed
     */
    @SuppressWarnings("unchecked")
    public NSDictionary<String, Object> changedProperties()
    {
        return changesFromSnapshot(
            editingContext().committedSnapshotForObject(this) );
    }


    // ----------------------------------------------------------
    /**
     * Retrieve this object's <code>id</code> value.
     * @return the value of the attribute
     */
    public Number id()
    {
        try
        {
            return (Number)EOUtilities.primaryKeyForObject(
                editingContext() , this ).objectForKey( "id" );
        }
        catch (Exception e)
        {
            return er.extensions.eof.ERXConstant.ZeroInteger;
        }
    }

#end## entity.parentSet
#foreach ($attribute in $entity.sortedClassAttributes)
#if (!$attribute.inherited)
#if ($attribute.userInfo.isMutable)
    //-- Local mutable cache --
    private ${attribute.userInfo.valueClassName} ${attribute.name}Cache;
    private ${attribute.javaClassName} ${attribute.name}RawCache;

    // ----------------------------------------------------------
    /**
     * Retrieve this object's <code>${attribute.name}</code> value.
     * @return the value of the attribute
     */
    public ${attribute.userInfo.valueClassName} ${attribute.name}()
    {
        ${attribute.javaClassName} dbValue =
            (${attribute.javaClassName})storedValueForKey( "${attribute.name}" );
        if ( ${attribute.name}RawCache != dbValue )
        {
            if ( dbValue != null && dbValue.equals( ${attribute.name}RawCache ) )
            {
                // They are still equal, so just update the raw cache
                ${attribute.name}RawCache = dbValue;
            }
            else
            {
                // Underlying attribute may have changed because
                // of a concurrent update through another editing
                // context, so throw away current values.
                ${attribute.name}RawCache = dbValue;
                ${attribute.userInfo.valueClassName} newValue =
                    ${attribute.userInfo.valueClassName}
                    .${attribute.userInfo.valueFactoryMethodName}( dbValue );
                if ( ${attribute.name}Cache != null )
                {
                    ${attribute.name}Cache.copyFrom( newValue );
                }
                else
                {
                    ${attribute.name}Cache = newValue;
                }
                ${attribute.name}Cache.setOwner( this );
                setUpdateMutableFields( true );
            }
        }
        else if ( dbValue == null && ${attribute.name}Cache == null )
        {
            ${attribute.name}Cache =
                ${attribute.userInfo.valueClassName}
                .${attribute.userInfo.valueFactoryMethodName}( dbValue );
             ${attribute.name}Cache.setOwner( this );
             setUpdateMutableFields( true );
        }
        return ${attribute.name}Cache;
    }


    // ----------------------------------------------------------
    /**
     * Change the value of this object's <code>${attribute.name}</code>
     * property.
     *
     * @param value The new value for this property
     */
    public void set${attribute.capitalizedName}( ${attribute.userInfo.valueClassName} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set${attribute.capitalizedName}("
                + value + ")" );
        }
        if ( ${attribute.name}Cache == null )
        {
            ${attribute.name}Cache = value;
            value.setHasChanged( false );
            ${attribute.name}RawCache = value.${attribute.userInfo.adaptorValueConversionMethodName}();
            takeStoredValueForKey( ${attribute.name}RawCache, "${attribute.name}" );
        }
        else if ( ${attribute.name}Cache != value )  // ( ${attribute.name}Cache != null )
        {
            ${attribute.name}Cache.copyFrom( value );
            setUpdateMutableFields( true );
        }
        else  // ( ${attribute.name}Cache == non-null value )
        {
            // no nothing
        }
    }


    // ----------------------------------------------------------
    /**
     * Clear the value of this object's <code>${attribute.name}</code>
     * property.
     */
    public void clear${attribute.capitalizedName}()
    {
        if (log.isDebugEnabled())
        {
            log.debug( "clear${attribute.capitalizedName}()" );
        }
        takeStoredValueForKey( null, "${attribute.name}" );
        ${attribute.name}RawCache = null;
        ${attribute.name}Cache = null;
    }


#else## !isMutable
#if ($attribute.userInfo.isScalar)
    // ----------------------------------------------------------
    /**
     * Retrieve this object's <code>${attribute.name}</code> value.
     * @return the value of the attribute
     */
    public ${attribute.userInfo.type} ${attribute.name}()
    {
        ${attribute.javaClassName} result =
            (${attribute.javaClassName})storedValueForKey( "${attribute.name}" );
        return ( result == null )
            ? ${attribute.userInfo.scalarDefault}
            : #if ($attribute.userInfo.type eq "boolean")( result.intValue() > 0 )#{else}result.${attribute.userInfo.scalarConversionMethodName}()#{end};
    }


    // ----------------------------------------------------------
    /**
     * Change the value of this object's <code>${attribute.name}</code>
     * property.
     *
     * @param value The new value for this property
     */
    public void set${attribute.capitalizedName}( ${attribute.userInfo.type} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set${attribute.capitalizedName}("
                + value + "): was " + ${attribute.name}() );
        }
        ${attribute.javaClassName} actual =
#if ($attribute.userInfo.type eq "boolean")
            er.extensions.eof.ERXConstant.integerForInt( value ? 1 : 0 );
#elseif ($attribute.userInfo.type eq "int"
      || $attribute.userInfo.type eq "byte"
      || $attribute.userInfo.type eq "short")
            er.extensions.eof.ERXConstant.integerForInt( value );
#else
            new ${attribute.userInfo.valueClassName}( value );
#end
            set${attribute.capitalizedName}Raw( actual );
    }


#end## isScalar
    // ----------------------------------------------------------
    /**
     * Retrieve this object's <code>${attribute.name}</code> value.
     * @return the value of the attribute
     */
    public ${attribute.javaClassName} ${attribute.name}#if ($attribute.userInfo.isScalar)Raw#{end}()
    {
        return (${attribute.javaClassName})storedValueForKey( "${attribute.name}" );
    }


    // ----------------------------------------------------------
    /**
     * Change the value of this object's <code>${attribute.name}</code>
     * property.
     *
     * @param value The new value for this property
     */
    public void set${attribute.capitalizedName}#if ($attribute.userInfo.isScalar)Raw#{end}( ${attribute.javaClassName} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set${attribute.capitalizedName}#if ($attribute.userInfo.isScalar)Raw#{end}("
                + value + "): was " + ${attribute.name}#if ($attribute.userInfo.isScalar)Raw#{end}() );
        }
        takeStoredValueForKey( value, "${attribute.name}" );
    }


#end## is or is not mutable
#end## !inherited
#end## for entity.sortedClassAttributes
#set ($alreadyFoundMutableAttribute = false)
#foreach ($attribute in $entity.sortedClassAttributes)## has mutables
#if ($attribute.userInfo.isMutable && !$alreadyFoundMutableAttribute)
#set ($alreadyFoundMutableAttribute = true)
    // ----------------------------------------------------------
    /**
     * Called just before this object is saved to the database.
     */
    public void saveMutables()
    {
        log.debug("saveMutables()");
#foreach ($attribute in $entity.sortedClassAttributes)## willUpdate
#if ($attribute.userInfo.isMutable)
        if ( ${attribute.name}Cache != null
            && ${attribute.name}Cache.hasChanged() )
        {
            ${attribute.name}RawCache = ${attribute.name}Cache.${attribute.userInfo.adaptorValueConversionMethodName}();
            takeStoredValueForKey( ${attribute.name}RawCache, "${attribute.name}" );
            ${attribute.name}Cache.setHasChanged( false );
        }
#end
#end## willUpdate

        setUpdateMutableFields( false );
    }


    // ----------------------------------------------------------
    /**
     * Called just before this object is saved to the database.
     */
    public void willUpdate()
    {
        log.debug("willUpdate()");
        saveMutables();
        super.willUpdate();
    }


    // ----------------------------------------------------------
    /**
     * Called just before this object is inserted into the database.
     */
    public void willInsert()
    {
        log.debug("willInsert()");
        saveMutables();
        super.willInsert();
    }


    // ----------------------------------------------------------
    /**
     * Called when the object is invalidated.
     */
    public void flushCaches()
    {
        log.debug("flushCaches()");
#foreach ($attribute in $entity.sortedClassAttributes)## flushCache
#if ($attribute.userInfo.isMutable)
        ${attribute.name}Cache = null;
        ${attribute.name}RawCache  = null;
#end
#end## flushCache
        super.flushCaches();
    }


    // ----------------------------------------------------------
    /**
     * Called when an owned mutable container object is changed.
     */
    public void mutableContainerHasChanged()
    {
        setUpdateMutableFields( true );
    }


#end
#end## has mutables
#set ($alreadyFoundMigratoryAttribute = false)
#foreach ($attribute in $entity.sortedClassAttributes)## has migratory attributes
#if (!$attribute.inherited)
#if ($attribute.userInfo.needsMigration && !$alreadyFoundMigratoryAttribute)
#set ($alreadyFoundMigratoryAttribute = true)
    // ----------------------------------------------------------
    @Override
    public void awakeFromFetch(EOEditingContext ec)
    {
        super.awakeFromFetch(ec);

        // Only try to migrate if the EC isn't a migrating context. If it is,
        // we're already trying to migrate and this "awake" is coming from the
        // child migration context.

        if (!(ec instanceof net.sf.webcat.core.MigratingEditingContext))
        {
            migrateAttributeValuesIfNeeded();
        }
    }


    // ----------------------------------------------------------
    /**
     * Called by {@link #awake} to migrate attribute values if needed when the
     * object is retrieved.
     */
    public void migrateAttributeValuesIfNeeded()
    {
        log.debug("migrateAttributeValuesIfNeeded()");

#set ($alreadyFoundOneMigratoryAttribute = false)
        if ( #foreach ($attribute in $entity.sortedClassAttributes)
#if ($attribute.userInfo.needsMigration)
#if ($alreadyFoundOneMigratoryAttribute)

            || #end
${attribute.name}Raw() == null#set ($alreadyFoundOneMigratoryAttribute = true)
#end
#end )
        {
            net.sf.webcat.core.MigratingEditingContext mec =
                net.sf.webcat.core.Application.newMigratingEditingContext();
            ${entity.classNameWithoutPackage} migratingObject = localInstance(mec);

#foreach ($attribute in $entity.sortedClassAttributes)
#if ($attribute.userInfo.needsMigration)
            if ( migratingObject.${attribute.name}Raw() == null )
            {
                migratingObject.${attribute.name}();
            }

#end
#end
            mec.saveChanges();
            net.sf.webcat.core.Application.releaseMigratingEditingContext(mec);
        }
    }


#end
#end
#end## has migratory attributes
#*
   Add methods to call named fetch specifications, with any qualifier bindings
   having typed parameters.

*##foreach ($relationship in $entity.sortedClassToOneRelationships)## toonerels
#if (!$relationship.inherited)
    // ----------------------------------------------------------
    /**
     * Retrieve the entity pointed to by the <code>${relationship.name}</code>
     * relationship.
     * @return the entity in the relationship
     */
    public ${relationship.actualDestination.classNameWithDefault} ${relationship.name}()
    {
        return (${relationship.actualDestination.classNameWithDefault})storedValueForKey( "${relationship.name}" );
    }


    // ----------------------------------------------------------
    /**
     * Set the entity pointed to by the <code>${relationship.name}</code>
     * relationship (DO NOT USE--instead, use
     * <code>set${relationship.capitalizedName}Relationship()</code>.
     * This method is provided for WebObjects use.
     *
     * @param value The new entity to relate to
     */
    public void set${relationship.capitalizedName}( ${relationship.actualDestination.classNameWithDefault} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set${relationship.capitalizedName}("
                + value + "): was " + ${relationship.name}() );
        }
        takeStoredValueForKey( value, "${relationship.name}" );
    }

#*
   The following method is better than using addObjectToBothSidesOf-
   RelationshipWithKey directly because you will get compile time type
   checking instead of runtime checking (plus you don't risk typos in
   constant strings of key names).
*#
    // ----------------------------------------------------------
    /**
     * Set the entity pointed to by the <code>${relationship.name}</code>
     * relationship.  This method is a type-safe version of
     * <code>addObjectToBothSidesOfRelationshipWithKey()</code>.
     *
     * @param value The new entity to relate to
     */
    public void set${relationship.capitalizedName}Relationship(
        ${relationship.actualDestination.classNameWithDefault} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set${relationship.capitalizedName}Relationship("
                + value + "): was " + ${relationship.name}() );
        }
        if ( value == null )
        {
            ${relationship.actualDestination.classNameWithDefault} object = ${relationship.name}();
            if ( object != null )
                removeObjectFromBothSidesOfRelationshipWithKey( object, "${relationship.name}" );
        }
        else
        {
            addObjectToBothSidesOfRelationshipWithKey( value, "${relationship.name}" );
        }
    }


#end## !inherited
#end## toonerels
#foreach ($relationship in $entity.sortedClassToManyRelationships)## tomanyrels
#if (!$relationship.inherited)
    // ----------------------------------------------------------
    /**
     * Retrieve the entities pointed to by the <code>${relationship.name}</code>
     * relationship.
     * @return an NSArray of the entities in the relationship
     */
    @SuppressWarnings("unchecked")
    public NSArray<${relationship.actualDestination.classNameWithDefault}> ${relationship.name}()
    {
        return (NSArray)storedValueForKey( "${relationship.name}" );
    }


    // ----------------------------------------------------------
    /**
     * Replace the list of entities pointed to by the
     * <code>${relationship.name}</code> relationship.
     *
     * @param value The new set of entities to relate to
     */
    public void set${relationship.capitalizedName}( NSMutableArray<${relationship.actualDestination.classNameWithDefault}>  value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set${relationship.capitalizedName}("
                + value + "): was " + ${relationship.name}() );
        }
        takeStoredValueForKey( value, "${relationship.name}" );
    }


    // ----------------------------------------------------------
    /**
     * Add a new entity to the <code>${relationship.name}</code>
     * relationship (DO NOT USE--instead, use
     * <code>addTo${relationship.capitalizedName}Relationship()</code>.
     * This method is provided for WebObjects use.
     *
     * @param value The new entity to relate to
     */
    public void addTo${relationship.capitalizedName}( ${relationship.actualDestination.classNameWithDefault} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "addTo${relationship.capitalizedName}("
                + value + "): was " + ${relationship.name}() );
        }
        NSMutableArray<${relationship.actualDestination.classNameWithDefault}> array =
            (NSMutableArray<${relationship.actualDestination.classNameWithDefault}>)${relationship.name}();
        willChange();
        array.addObject( value );
    }


    // ----------------------------------------------------------
    /**
     * Remove a specific entity from the <code>${relationship.name}</code>
     * relationship (DO NOT USE--instead, use
     * <code>removeFrom${relationship.capitalizedName}Relationship()</code>.
     * This method is provided for WebObjects use.
     *
     * @param value The entity to remove from the relationship
     */
    public void removeFrom${relationship.capitalizedName}( ${relationship.actualDestination.classNameWithDefault} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "RemoveFrom${relationship.capitalizedName}("
                + value + "): was " + ${relationship.name}() );
        }
        NSMutableArray<${relationship.actualDestination.classNameWithDefault}> array =
            (NSMutableArray<${relationship.actualDestination.classNameWithDefault}>)${relationship.name}();
        willChange();
        array.removeObject( value );
    }

#*
   The following adds typed methods to add or remove an object from a to-many
   relationship. This is better than using addObjectToBothSidesOfRelationship-
   WithKey directly because you will get compile time type checking instead of
   runtime checking, and you avoid the possibility of making a typo in the key
   name.
*#
    // ----------------------------------------------------------
    /**
     * Add a new entity to the <code>${relationship.name}</code>
     * relationship.
     *
     * @param value The new entity to relate to
     */
    public void addTo${relationship.capitalizedName}Relationship( ${relationship.actualDestination.classNameWithDefault} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "addTo${relationship.capitalizedName}Relationship("
                + value + "): was " + ${relationship.name}() );
        }
        addObjectToBothSidesOfRelationshipWithKey(
            value, "${relationship.name}" );
    }


    // ----------------------------------------------------------
    /**
     * Remove a specific entity from the <code>${relationship.name}</code>
     * relationship.
     *
     * @param value The entity to remove from the relationship
     */
    public void removeFrom${relationship.capitalizedName}Relationship( ${relationship.actualDestination.classNameWithDefault} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "removeFrom${relationship.capitalizedName}Relationship("
                + value + "): was " + ${relationship.name}() );
        }
        removeObjectFromBothSidesOfRelationshipWithKey(
            value, "${relationship.name}" );
    }

#*
   The following adds typed methods to create, and delete objects from a to-
   many relationship. The main difference in the delete mechanism, versus the
   removeFrom... method above is that this delete method will remove the object
   from the editing context if it is we do not own its destination.  The user
   can override these methods in the subclass to provide additional
   functionality on these methods.
*#
    // ----------------------------------------------------------
    /**
     * Create a brand new object that is a member of the
     * <code>${relationship.name}</code> relationship.
     *
     * @return The new entity
     */
    public ${relationship.actualDestination.classNameWithDefault} create${relationship.capitalizedName}Relationship()
    {
        if (log.isDebugEnabled())
        {
            log.debug( "create${relationship.capitalizedName}Relationship()" );
        }
        EOClassDescription eoClassDesc = EOClassDescription
            .classDescriptionForEntityName( "${relationship.actualDestination.name}" );
        EOEnterpriseObject eoObject = eoClassDesc
            .createInstanceWithEditingContext( editingContext(), null );
        editingContext().insertObject( eoObject );
        addObjectToBothSidesOfRelationshipWithKey(
            eoObject, "${relationship.name}" );
        return (${relationship.actualDestination.classNameWithDefault})eoObject;
    }


    // ----------------------------------------------------------
    /**
     * Remove#if (!$relationship.ownsDestination) and then delete#end a specific entity that is a member of the
     * <code>${relationship.name}</code> relationship.
     *
     * @param value The entity to remove from the relationship#if (!$relationship.ownsDestination) and then delete#end

     */
    public void delete${relationship.capitalizedName}Relationship( ${relationship.actualDestination.classNameWithDefault} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "delete${relationship.capitalizedName}Relationship("
                + value + "): was " + ${relationship.name}() );
        }
        removeObjectFromBothSidesOfRelationshipWithKey(
            value, "${relationship.name}" );
#if (!$relationship.ownsDestination)
        editingContext().deleteObject( value );
#end
    }


    // ----------------------------------------------------------
    /**
     * Remove (and then delete, if owned) all entities that are members of the
     * <code>${relationship.name}</code> relationship.
     */
    public void deleteAll${relationship.capitalizedName}Relationships()
    {
        if (log.isDebugEnabled())
        {
            log.debug( "deleteAll${relationship.capitalizedName}Relationships(): was "
                + ${relationship.name}() );
        }
        Enumeration<?> objects = ${relationship.name}().objectEnumerator();
        while ( objects.hasMoreElements() )
            delete${relationship.capitalizedName}Relationship(
                (${relationship.actualDestination.classNameWithDefault})objects.nextElement() );
    }


#end## !inherited
#end## tomanyrels
#if (!$entity.abstractEntity)
    // ----------------------------------------------------------
    /**
     * Retrieve objects using a fetch specification.
     *
     * @param context The editing context to use
     * @param fspec The fetch specification to use
     *
     * @return an NSArray of the entities retrieved
     */
    @SuppressWarnings("unchecked")
    public static NSArray<${entity.classNameWithoutPackage}> objectsWithFetchSpecification(
        EOEditingContext context,
        EOFetchSpecification fspec)
    {
        return context.objectsWithFetchSpecification(fspec);
    }


    // ----------------------------------------------------------
    /**
     * Retrieve all objects of this type.
     *
     * @param context The editing context to use
     *
     * @return an NSArray of the entities retrieved
     */
    public static NSArray<${entity.classNameWithoutPackage}> allObjects(
        EOEditingContext context)
    {
        return objectsMatchingQualifier(context, null, null);
    }


    // ----------------------------------------------------------
    /**
     * Retrieve objects using a qualifier.
     *
     * @param context The editing context to use
     * @param qualifier The qualifier to use
     *
     * @return an NSArray of the entities retrieved
     */
    public static NSArray<${entity.classNameWithoutPackage}> objectsMatchingQualifier(
        EOEditingContext context,
        EOQualifier qualifier)
    {
        return objectsMatchingQualifier(context, qualifier, null);
    }


    // ----------------------------------------------------------
    /**
     * Retrieve objects using a qualifier and sort orderings.
     *
     * @param context The editing context to use
     * @param qualifier The qualifier to use
     * @param sortOrderings The sort orderings to use
     *
     * @return an NSArray of the entities retrieved
     */
    public static NSArray<${entity.classNameWithoutPackage}> objectsMatchingQualifier(
        EOEditingContext context,
        EOQualifier qualifier,
        NSArray<EOSortOrdering> sortOrderings)
    {
        EOFetchSpecification fspec = new EOFetchSpecification(
            ENTITY_NAME, qualifier, sortOrderings);
        fspec.setUsesDistinct(true);
        return objectsWithFetchSpecification(context, fspec);
    }


    // ----------------------------------------------------------
    /**
     * Retrieve objects using a list of keys and values to match.
     *
     * @param context The editing context to use
     * @param keysAndValues a list of keys and values to match, alternating
     *     "key", "value", "key", "value"...
     *
     * @return an NSArray of the entities retrieved
     */
    public static NSArray<${entity.classNameWithoutPackage}> objectsMatchingValues(
        EOEditingContext context,
        Object... keysAndValues)
    {
        if (keysAndValues.length % 2 != 0)
        {
            throw new IllegalArgumentException("There should a value " +
                "corresponding to every key that was passed.");
        }

        NSMutableDictionary<String, Object> valueDictionary =
            new NSMutableDictionary<String, Object>();

        for (int i = 0; i < keysAndValues.length; i += 2)
        {
            Object key = keysAndValues[i];
            Object value = keysAndValues[i + 1];

            if (!(key instanceof String))
            {
                throw new IllegalArgumentException("Keys should be strings.");
            }

            valueDictionary.setObjectForKey(value, key);
        }

        return objectsMatchingValues(context, valueDictionary);
    }


    // ----------------------------------------------------------
    /**
     * Retrieve objects using a dictionary of keys and values to match.
     *
     * @param context The editing context to use
     * @param keysAndValues a dictionary of keys and values to match
     *
     * @return an NSArray of the entities retrieved
     */
    @SuppressWarnings("unchecked")
    public static NSArray<${entity.classNameWithoutPackage}> objectsMatchingValues(
        EOEditingContext context,
        NSDictionary<String, Object> keysAndValues)
    {
        return EOUtilities.objectsMatchingValues(context, ENTITY_NAME,
            keysAndValues);
    }


    // ----------------------------------------------------------
    /**
     * Retrieve a single object using a list of keys and values to match.
     *
     * @param context The editing context to use
     * @param keysAndValues a list of keys and values to match, alternating
     *     "key", "value", "key", "value"...
     *
     * @return the single entity that was retrieved
     *
     * @throws EOObjectNotAvailableException
     *     if there is no matching object
     * @throws EOUtilities.MoreThanOneException
     *     if there is more than one matching object
     */
    public static ${entity.classNameWithoutPackage} objectMatchingValues(
        EOEditingContext context,
        Object... keysAndValues) throws EOObjectNotAvailableException,
                                        EOUtilities.MoreThanOneException
    {
        if (keysAndValues.length % 2 != 0)
        {
            throw new IllegalArgumentException("There should a value " +
                "corresponding to every key that was passed.");
        }

        NSMutableDictionary<String, Object> valueDictionary =
            new NSMutableDictionary<String, Object>();

        for (int i = 0; i < keysAndValues.length; i += 2)
        {
            Object key = keysAndValues[i];
            Object value = keysAndValues[i + 1];

            if (!(key instanceof String))
            {
                throw new IllegalArgumentException("Keys should be strings.");
            }

            valueDictionary.setObjectForKey(value, key);
        }

        return objectMatchingValues(context, valueDictionary);
    }


    // ----------------------------------------------------------
    /**
     * Retrieve an object using a dictionary of keys and values to match.
     *
     * @param context The editing context to use
     * @param keysAndValues a dictionary of keys and values to match
     *
     * @return the single entity that was retrieved
     *
     * @throws EOObjectNotAvailableException
     *     if there is no matching object
     * @throws EOUtilities.MoreThanOneException
     *     if there is more than one matching object
     */
    public static ${entity.classNameWithoutPackage} objectMatchingValues(
        EOEditingContext context,
        NSDictionary<String, Object> keysAndValues)
        throws EOObjectNotAvailableException,
               EOUtilities.MoreThanOneException
    {
        return (${entity.classNameWithoutPackage})EOUtilities.objectMatchingValues(
            context, ENTITY_NAME, keysAndValues);
    }


#foreach ($fetchSpec in $entity.sortedFetchSpecs)## fetchspec
    // ----------------------------------------------------------
    /**
     * Retrieve object according to the <code>${fetchSpec.capitalizedName}</code>
     * fetch specification.
     *
     * @param context The editing context to use
#foreach ($binding in $fetchSpec.distinctBindings)
     * @param ${binding.name}Binding fetch spec parameter
#end
     * @return an NSArray of the entities retrieved
     */
    public static NSArray<${entity.classNameWithoutPackage}> objectsFor${fetchSpec.capitalizedName}(
            EOEditingContext context#foreach ($binding in $fetchSpec.distinctBindings),
            ${binding.attributePath.childClassName} ${binding.name}Binding#end

        )
    {
        EOFetchSpecification spec = EOFetchSpecification
            .fetchSpecificationNamed( "${fetchSpec.name}", "${entity.name}" );
#if ($fetchSpec.distinctBindings.size() > 0)

        NSMutableDictionary<String, Object> bindings =
            new NSMutableDictionary<String, Object>();

#foreach ($binding in $fetchSpec.distinctBindings)
        if ( ${binding.name}Binding != null )
        {
            bindings.setObjectForKey( ${binding.name}Binding,
                                      "${binding.name}" );
        }
#end
        spec = spec.fetchSpecificationWithQualifierBindings( bindings );
#end

        NSArray<${entity.classNameWithoutPackage}> result = objectsWithFetchSpecification( context, spec );
        if (log.isDebugEnabled())
        {
            log.debug( "objectsFor${fetchSpec.capitalizedName}(ec"
#foreach ($binding in $fetchSpec.distinctBindings)
                + ", " + ${binding.name}Binding
#end
                + "): " + result );
        }
        return result;
    }


#end## fetchspec
#end
    // ----------------------------------------------------------
    /**
     * Produce a string representation of this object.  This implementation
     * calls UserPresentableDescription(), which uses WebObjects' internal
     * mechanism to print out the visible fields of this object.  Normally,
     * subclasses would override userPresentableDescription() to change
     * the way the object is printed.
     *
     * @return A string representation of the object's value
     */
    public String toString()
    {
        return userPresentableDescription();
    }

#if ($entity.abstractEntity)

    // ----------------------------------------------------------
    /**
     * Hack to workaround the need to include the base relationship when
     * fetching objects vs. getting/setting their values via KVC.
     *
     * @param key the key to access
     * @return the value of the key
     */
    public Object valueForKey(String key)
    {
        if (key.equals(BASE_PREFIX))
        {
            return this;
        }

        if (key.startsWith(BASE_PREFIX_DOT))
        {
            key = key.substring(BASE_PREFIX_DOT.length());
        }

        return super.valueForKey(key);
    }


    // ----------------------------------------------------------
    /**
     * Hack to workaround the need to include the base relationship when
     * fetching objects vs. getting/setting their values via KVC.
     *
     * @param value the new value of the key
     * @param key the key to access
     */
    public void takeValueForKey(Object value, String key)
    {
        if (key.startsWith(BASE_PREFIX_DOT))
        {
            key = key.substring(BASE_PREFIX_DOT.length());
        }

        super.takeValueForKey(value, key);
    }

#end

    //~ Instance/static variables .............................................

    static Logger log = Logger.getLogger( ${entity.classNameWithoutPackage}.class );
}
